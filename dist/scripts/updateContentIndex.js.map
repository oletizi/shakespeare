{
  "version": 3,
  "sources": ["../../src/utils/scanner.ts", "../../src/types/interfaces.ts", "../../src/utils/database.ts", "../../src/utils/constants.ts", "../../src/utils/goose.ts", "../../src/utils/ai.ts", "../../src/index.ts", "../../src/scripts/updateContentIndex.ts"],
  "sourcesContent": ["import fs from 'fs/promises';\nimport path from 'path';\nimport { IContentScanner, ContentCollectionConfig, CONTENT_COLLECTIONS } from '@/types/interfaces';\n\n/**\n * Content scanner with configurable content collection support\n */\nexport class ContentScanner implements IContentScanner {\n  private config: ContentCollectionConfig;\n  private rootDir: string;\n\n  constructor(rootDir: string = process.cwd(), config?: ContentCollectionConfig | keyof typeof CONTENT_COLLECTIONS) {\n    this.rootDir = rootDir;\n    \n    // Handle different config types\n    if (typeof config === 'string') {\n      this.config = CONTENT_COLLECTIONS[config] as ContentCollectionConfig;\n    } else if (config) {\n      this.config = config;\n    } else {\n      // Default to Astro content collections\n      this.config = CONTENT_COLLECTIONS.astro as ContentCollectionConfig;\n    }\n  }\n\n  /**\n   * Scan for content files based on configuration\n   */\n  async scanContent(): Promise<string[]> {\n    const contentDir = path.resolve(this.rootDir, this.config.baseDir);\n    \n    // Check if content directory exists\n    try {\n      await fs.access(contentDir);\n    } catch {\n      throw new Error(`Content directory not found: ${contentDir}. Make sure the directory exists or configure a different baseDir.`);\n    }\n\n    const contentFiles: string[] = [];\n    \n    const scan = async (dir: string, relativePath: string = ''): Promise<void> => {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n        const relativeFilePath = path.join(relativePath, entry.name);\n        \n        if (entry.isDirectory()) {\n          await scan(fullPath, relativeFilePath);\n        } else if (entry.isFile()) {\n          // Check if file matches include patterns\n          const shouldInclude = this.matchesPatterns(relativeFilePath, this.config.include);\n          const shouldExclude = this.config.exclude && this.matchesPatterns(relativeFilePath, this.config.exclude);\n          \n          if (shouldInclude && !shouldExclude) {\n            contentFiles.push(fullPath);\n          }\n        }\n      }\n    };\n\n    await scan(contentDir);\n    return contentFiles.sort();\n  }\n\n  /**\n   * Check if a file path matches any of the given glob-like patterns\n   */\n  private matchesPatterns(filePath: string, patterns: readonly string[]): boolean {\n    return patterns.some(pattern => this.matchesPattern(filePath, pattern));\n  }\n\n  /**\n   * Simple glob pattern matching (supports ** and * wildcards)\n   */\n  private matchesPattern(filePath: string, pattern: string): boolean {\n    // Normalize path separators\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\n    const normalizedPattern = pattern.replace(/\\\\/g, '/');\n    \n    // Convert glob pattern to regex\n    let regexPattern = normalizedPattern\n      .replace(/\\./g, '\\\\.')     // Escape dots first\n      .replace(/\\*\\*\\//g, '___DOUBLESTARSLASH___')  // Handle **/ first\n      .replace(/\\*\\*/g, '___DOUBLESTAR___')  // Handle remaining ** \n      .replace(/\\*/g, '[^/]*')   // * matches any filename characters except /\n      .replace(/___DOUBLESTARSLASH___/g, '(?:.*/)?') // **/ matches any path including / (optional for root level)\n      .replace(/___DOUBLESTAR___/g, '(?:.*/)?'); // ** matches any path including / (optional for root level)\n    \n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(normalizedPath);\n  }\n\n  /**\n   * Read content of a markdown file\n   */\n  async readContent(filePath: string): Promise<string> {\n    return fs.readFile(filePath, 'utf-8');\n  }\n}\n", "import { ContentDatabase, ContentEntry } from './content';\nimport { AIContentAnalysis } from '../utils/ai';\n\n/**\n * Content collection configuration for different frameworks\n */\nexport interface ContentCollectionConfig {\n  /** Base directory to scan for content */\n  baseDir: string;\n  /** File patterns to include (glob patterns) */\n  include: readonly string[];\n  /** File patterns to exclude (glob patterns) */\n  exclude?: readonly string[];\n  /** Framework-specific settings */\n  framework?: 'astro' | 'nextjs' | 'gatsby' | 'custom';\n}\n\n/**\n * Predefined content collection configurations\n */\nexport const CONTENT_COLLECTIONS = {\n  astro: {\n    baseDir: 'src/content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/index.md', '**/README.md'],\n    framework: 'astro' as const\n  },\n  nextjs: {\n    baseDir: 'content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/README.md'],\n    framework: 'nextjs' as const\n  },\n  gatsby: {\n    baseDir: 'content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/README.md'],\n    framework: 'gatsby' as const\n  },\n  custom: (baseDir: string, include: string[] = ['**/*.md'], exclude: string[] = []) => ({\n    baseDir,\n    include,\n    exclude,\n    framework: 'custom' as const\n  })\n} as const;\n\n/**\n * Interface for AI interaction\n */\nexport interface IAI {\n  prompt(prompt: string): Promise<string>;\n}\n\n/**\n * Interface for file system operations\n */\nexport interface IFileSystem {\n  readFile(path: string, encoding?: BufferEncoding): Promise<string>;\n  writeFile(path: string, data: string, encoding?: BufferEncoding): Promise<void>;\n  readdir(path: string, options?: { withFileTypes?: boolean }): Promise<any[]>;\n  mkdir(path: string, options?: { recursive?: boolean }): Promise<void>;\n}\n\n/**\n * Interface for content scanning\n */\nexport interface IContentScanner {\n  scanContent(): Promise<string[]>;\n  readContent(filePath: string): Promise<string>;\n}\n\n/**\n * Interface for database operations\n */\nexport interface IContentDatabase {\n  load(): Promise<ContentDatabase>;\n  save(): Promise<void>;\n  getData(): ContentDatabase;\n  updateEntry(entryPath: string, updateFn: (entry: ContentEntry | undefined) => ContentEntry): Promise<void>;\n}\n\n/**\n * Interface for AI content scoring\n */\nexport interface IContentScorer {\n  scoreContent(content: string): Promise<AIContentAnalysis>;\n  improveContent(content: string, analysis: AIContentAnalysis): Promise<string>;\n}", "import fs from 'fs/promises';\nimport path from 'path';\nimport { ContentDatabase, ContentEntry } from '@/types/content';\nimport { IContentDatabase } from '@/types/interfaces';\n\nexport { ContentDatabase as ContentDatabaseType } from '@/types/content';\n\n/**\n * Database handler for content tracking\n */\nexport class ContentDatabaseHandler implements IContentDatabase {\n  private dbPath: string;\n  private dbDir: string;\n  private data: ContentDatabase = {\n    lastUpdated: new Date().toISOString(),\n    entries: {}\n  };\n\n  constructor(dbPath: string) {\n    this.dbPath = dbPath;\n    this.dbDir = path.dirname(dbPath);\n  }\n\n  /**\n   * Convert absolute path to relative path from database directory\n   */\n  private toRelativePath(absolutePath: string): string {\n    return path.relative(this.dbDir, absolutePath);\n  }\n\n  /**\n   * Convert relative path to absolute path from database directory\n   */\n  private toAbsolutePath(relativePath: string): string {\n    return path.resolve(this.dbDir, relativePath);\n  }\n\n  /**\n   * Load the database from disk\n   */\n  async load(): Promise<ContentDatabase> {\n    try {\n      const content = await fs.readFile(this.dbPath, 'utf-8');\n      this.data = JSON.parse(content);\n      \n      // Convert stored relative paths to absolute paths for internal use\n      const normalizedEntries: { [key: string]: ContentEntry } = {};\n      for (const [relativePath, entry] of Object.entries(this.data.entries)) {\n        const absolutePath = this.toAbsolutePath(relativePath);\n        normalizedEntries[absolutePath] = {\n          ...entry,\n          path: absolutePath // Ensure entry.path is also absolute\n        };\n      }\n      this.data.entries = normalizedEntries;\n      \n      return this.data;\n    } catch (error) {\n      // If file doesn't exist, create new database\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        await this.save();\n        return this.data;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Save the database to disk\n   */\n  async save(): Promise<void> {\n    this.data.lastUpdated = new Date().toISOString();\n    \n    // Convert absolute paths to relative paths for storage\n    const storageData: ContentDatabase = {\n      ...this.data,\n      entries: {}\n    };\n    \n    for (const [absolutePath, entry] of Object.entries(this.data.entries)) {\n      const relativePath = this.toRelativePath(absolutePath);\n      storageData.entries[relativePath] = {\n        ...entry,\n        path: relativePath // Store relative path in entry.path as well\n      };\n    }\n    \n    await fs.writeFile(this.dbPath, JSON.stringify(storageData, null, 2));\n  }\n\n  /**\n   * Get the current database state\n   */\n  getData(): ContentDatabase {\n    return this.data;\n  }\n\n  /**\n   * Update an entry in the database\n   */\n  async updateEntry(entryPath: string, updateFn: (entry: ContentEntry | undefined) => ContentEntry): Promise<void> {\n    this.data.entries[entryPath] = updateFn(this.data.entries[entryPath]);\n    await this.save();\n  }\n}\n", "import { QualityDimensions } from '../types/content';\n\n/**\n * Default target scores for content quality\n */\nexport const DEFAULT_TARGET_SCORES: QualityDimensions = {\n  readability: 8.0,\n  seoScore: 8.5,\n  technicalAccuracy: 9.0,\n  engagement: 8.0,\n  contentDepth: 8.5\n};\n\n/**\n * Configuration for content improvement\n */\nexport const IMPROVEMENT_CONFIG = {\n  maxIterations: 3,\n  minScoreImprovement: 0.5,\n  scoreThreshold: 7.0\n};\n", "import { spawn } from 'child_process';\nimport { IAI } from '@/types/interfaces';\n\n/**\n * Goose AI interaction handler using CLI in headless mode\n */\nexport class GooseAI implements IAI {\n  private gooseCommand: string;\n  private cwd: string;\n\n  constructor(cwd: string = process.cwd()) {\n    this.gooseCommand = 'goose'; // Assumes goose is in PATH\n    this.cwd = cwd;\n  }\n\n  /**\n   * Send a prompt to Goose and get the response using headless mode\n   */\n  async prompt(prompt: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n      // Use goose run with --no-session and --quiet for headless automation\n      const args = ['run', '--no-session', '--quiet', '--text', prompt];\n      \n      const goose = spawn(this.gooseCommand, args, {\n        cwd: this.cwd,\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n\n      let output = '';\n      let error = '';\n\n      goose.stdout.on('data', (data) => {\n        output += data.toString();\n      });\n\n      goose.stderr.on('data', (data) => {\n        error += data.toString();\n      });\n\n      goose.on('close', (code) => {\n        if (code !== 0) {\n          reject(new Error(`Goose failed with code ${code}: ${error}`));\n        } else {\n          resolve(output.trim());\n        }\n      });\n\n      // No need to write to stdin with --text flag\n    });\n  }\n}\n", "import { GooseAI } from '@/utils/goose';\nimport { QualityDimensions } from '@/types/content';\nimport { IAI, IContentScorer } from '@/types/interfaces';\n\nexport interface AIScoreResponse {\n  score: number;\n  reasoning: string;\n  suggestions?: string[];\n}\n\nexport interface AIContentAnalysis {\n  scores: QualityDimensions;\n  analysis: {\n    [K in keyof QualityDimensions]: {\n      reasoning: string;\n      suggestions: string[];\n    }\n  };\n}\n\n/**\n * Prompts for content analysis\n */\nexport const ANALYSIS_PROMPTS = {\n  readability: `\n    Analyze the following content for readability. Consider:\n    - Sentence structure and length\n    - Vocabulary level and consistency\n    - Paragraph organization\n    - Use of transitions\n    - Clear and concise explanations\n    \n    Score from 0-10 where:\n    0-3: Difficult to read, needs major revision\n    4-6: Somewhat readable but needs improvement\n    7-8: Good readability\n    9-10: Excellent, clear and engaging\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `,\n\n  seoScore: `\n    Evaluate the following content for SEO effectiveness. Consider:\n    - Keyword usage and placement\n    - Meta description potential\n    - Header structure and organization\n    - Internal/external linking opportunities\n    - Content length and depth\n    \n    Score from 0-10 where:\n    0-3: Poor SEO optimization\n    4-6: Basic SEO implementation\n    7-8: Good SEO practices\n    9-10: Excellent SEO optimization\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `,\n\n  technicalAccuracy: `\n    Review the following content for technical accuracy. Consider:\n    - Factual correctness\n    - Code examples (if any)\n    - Technical terminology usage\n    - Up-to-date information\n    - Technical depth appropriate for the topic\n    \n    Score from 0-10 where:\n    0-3: Contains significant technical errors\n    4-6: Some technical inaccuracies\n    7-8: Generally accurate with minor issues\n    9-10: Highly accurate and well-researched\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `,\n\n  engagement: `\n    Evaluate the content's engagement level. Consider:\n    - Writing style and tone\n    - Use of examples and analogies\n    - Reader interaction elements\n    - Story-telling elements\n    - Call-to-action effectiveness\n    \n    Score from 0-10 where:\n    0-3: Dry and unengaging\n    4-6: Somewhat engaging but could improve\n    7-8: Good engagement level\n    9-10: Highly engaging and compelling\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `,\n\n  contentDepth: `\n    Analyze the content's depth and comprehensiveness. Consider:\n    - Topic coverage breadth\n    - Supporting evidence and examples\n    - Explanation thoroughness\n    - Context and background information\n    - Advanced concept handling\n    \n    Score from 0-10 where:\n    0-3: Surface level only\n    4-6: Basic coverage with some depth\n    7-8: Good depth with most aspects covered\n    9-10: Comprehensive and thorough coverage\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `\n};\n\n/**\n * Prompt for content improvement\n */\nexport const IMPROVEMENT_PROMPT = `\nYou are a content improvement specialist. Review the following content and its quality analysis.\nFocus on the dimensions that scored lowest and provide specific improvements.\n\nCurrent scores and analysis:\n{analysis}\n\nOriginal content:\n{content}\n\nPlease provide:\n1. Improved version of the content\n2. Summary of changes made\n3. Expected impact on quality scores\n\nMake sure to maintain any technical accuracy while improving readability and engagement.\nPreserve the original meaning and intent while enhancing the presentation and effectiveness.\n`;\n\n/**\n * Parse Goose response to extract score, reasoning, and suggestions\n */\nfunction parseGooseResponse(response: string): AIScoreResponse {\n  // Example response parsing - adjust based on actual Goose output format\n  const lines = response.split('\\n').map(l => l.trim()).filter(Boolean);\n  \n  let score = 7.0; // Default score\n  let reasoning = '';\n  const suggestions: string[] = [];\n  \n  for (const line of lines) {\n    if (line.match(/^\\d+(\\.\\d+)?$/)) {\n      score = parseFloat(line);\n    } else if (line.startsWith('- ')) {\n      suggestions.push(line.slice(2));\n    } else {\n      reasoning = line;\n    }\n  }\n  \n  return {\n    score,\n    reasoning,\n    suggestions\n  };\n}\n\n/**\n * Options for AIScorer constructor\n */\nexport interface AIScorerOptions {\n  ai?: IAI;\n}\n\n/**\n * AI scoring system implementation\n */\nexport class AIScorer implements IContentScorer {\n  private ai: IAI;\n\n  constructor(options: AIScorerOptions = {}) {\n    this.ai = options.ai ?? new GooseAI();\n  }\n\n  /**\n   * Score content across all quality dimensions\n   */\n  async scoreContent(content: string): Promise<AIContentAnalysis> {\n    const analysis: Partial<AIContentAnalysis> = {\n      scores: {} as QualityDimensions,\n      analysis: {} as AIContentAnalysis['analysis']\n    };\n\n    // Score each dimension\n    for (const [dimension, promptTemplate] of Object.entries(ANALYSIS_PROMPTS)) {\n      const prompt = promptTemplate.replace('{content}', content);\n      const result = await this.scoreDimension(content, prompt);\n      \n      // Update scores and analysis\n      (analysis.scores as any)[dimension] = result.score;\n      (analysis.analysis as any)[dimension] = {\n        reasoning: result.reasoning,\n        suggestions: result.suggestions || []\n      };\n    }\n\n    return analysis as AIContentAnalysis;\n  }\n\n  /**\n   * Score content for a specific dimension\n   */\n  private async scoreDimension(content: string, prompt: string): Promise<AIScoreResponse> {\n    try {\n      const response = await this.ai.prompt(prompt);\n      return parseGooseResponse(response);\n    } catch (error) {\n      console.error('Error scoring content:', error);\n      return {\n        score: 5.0,\n        reasoning: 'Error during scoring process',\n        suggestions: ['Retry scoring']\n      };\n    }\n  }\n\n  /**\n   * Generate improved content based on analysis\n   */\n  async improveContent(content: string, analysis: AIContentAnalysis): Promise<string> {\n    const analysisStr = JSON.stringify(analysis, null, 2);\n    const prompt = IMPROVEMENT_PROMPT\n      .replace('{analysis}', analysisStr)\n      .replace('{content}', content);\n\n    try {\n      const response = await this.ai.prompt(prompt);\n      // Extract the improved content from the response\n      // This might need adjustment based on actual Goose output format\n      const sections = response.split('\\n\\n');\n      return sections[0] || content; // Return first section or original if parsing fails\n    } catch (error) {\n      console.error('Error improving content:', error);\n      return content;\n    }\n  }\n}\n\n/**\n * Factory function for creating AIScorer instances\n */\nexport function createAIScorer(options?: AIScorerOptions): AIScorer {\n  return new AIScorer(options);\n}\n", "import { ContentScanner } from '@/utils/scanner';\nimport { ContentDatabaseHandler } from '@/utils/database';\nimport { DEFAULT_TARGET_SCORES } from '@/utils/constants';\nimport { ContentEntry, QualityDimensions } from '@/types/content';\nimport { AIScorer, AIContentAnalysis } from '@/utils/ai';\nimport { IContentScanner, IContentDatabase, IContentScorer, ContentCollectionConfig, CONTENT_COLLECTIONS } from '@/types/interfaces';\nimport path from 'path';\nimport fs from 'fs/promises';\n\nexport * from '@/types/content';\nexport * from '@/types/interfaces';\n\n/**\n * Options for Shakespeare constructor\n */\nexport interface ShakespeareOptions {\n  scanner?: IContentScanner;\n  database?: IContentDatabase;\n  ai?: IContentScorer;\n  /** Content collection configuration */\n  contentCollection?: ContentCollectionConfig | keyof typeof CONTENT_COLLECTIONS;\n}\n\nexport class Shakespeare {\n  private scanner: IContentScanner;\n  private db: IContentDatabase;\n  private ai: IContentScorer;\n  private rootDir: string;\n  private dbPath: string;\n\n  constructor(rootDir: string = process.cwd(), dbPath?: string, options: ShakespeareOptions = {}) {\n    this.rootDir = rootDir;\n    this.dbPath = dbPath ?? path.join(rootDir, '.shakespeare', 'content-db.json');\n    \n    // Create scanner with content collection configuration\n    this.scanner = options.scanner ?? new ContentScanner(rootDir, options.contentCollection);\n    this.db = options.database ?? new ContentDatabaseHandler(this.dbPath);\n    this.ai = options.ai ?? new AIScorer();\n\n    // Ensure database directory exists\n    const dbDir = path.dirname(this.dbPath);\n    fs.mkdir(dbDir, { recursive: true }).catch(console.error);\n  }\n\n  /**\n   * Initialize the system\n   */\n  async initialize(): Promise<void> {\n    await this.db.load();\n  }\n\n  /**\n   * Discover and index content without scoring (lightweight operation)\n   * Creates database entries for new files with 'needs_review' status\n   */\n  async discoverContent(): Promise<string[]> {\n    const files = await this.scanner.scanContent();\n    const database = this.db.getData();\n    const newFiles: string[] = [];\n\n    for (const file of files) {\n      if (!database.entries[file]) {\n        // Create lightweight entry without AI scoring\n        const newEntry: ContentEntry = {\n          path: file,\n          currentScores: {\n            readability: 0,\n            seoScore: 0,\n            technicalAccuracy: 0,\n            engagement: 0,\n            contentDepth: 0\n          },\n          targetScores: DEFAULT_TARGET_SCORES,\n          lastReviewDate: new Date().toISOString(),\n          improvementIterations: 0,\n          status: 'needs_review', // Mark as unreviewed\n          reviewHistory: []\n        };\n\n        await this.db.updateEntry(file, (_entry: ContentEntry | undefined) => newEntry);\n        newFiles.push(file);\n      }\n    }\n\n    // Update database timestamp\n    await this.db.save();\n    \n    return newFiles;\n  }\n\n  /**\n   * Update content index with new files\n   */\n  async updateContentIndex(): Promise<void> {\n    const files = await this.scanner.scanContent();\n    const database = this.db.getData();\n\n    for (const file of files) {\n      if (!database.entries[file]) {\n        // Initialize new content entry\n        const content = await this.scanner.readContent(file);\n        const analysis = await this.ai.scoreContent(content);\n\n        const newEntry: ContentEntry = {\n          path: file,\n          currentScores: analysis.scores,\n          targetScores: DEFAULT_TARGET_SCORES,\n          lastReviewDate: new Date().toISOString(),\n          improvementIterations: 0,\n          status: this.determineStatus(analysis.scores),\n          reviewHistory: [{\n            date: new Date().toISOString(),\n            scores: analysis.scores,\n            improvements: []\n          }]\n        };\n\n        await this.db.updateEntry(file, (_entry: ContentEntry | undefined) => newEntry);\n      }\n    }\n  }\n\n  /**\n   * Get the current database data\n   */\n  getDatabaseData() {\n    return this.db.getData();\n  }\n\n  /**\n   * Get content that needs review (unreviewed/discovered content)\n   */\n  getContentNeedingReview(): string[] {\n    const database = this.db.getData();\n    return Object.entries(database.entries)\n      .filter(([_, entry]) => entry.status === 'needs_review')\n      .map(([path, _]) => path);\n  }\n\n  /**\n   * Review/score a specific content file\n   */\n  async reviewContent(path: string): Promise<void> {\n    const database = this.db.getData();\n    const entry = database.entries[path];\n    \n    if (!entry) {\n      throw new Error(`Content not found: ${path}`);\n    }\n\n    if (entry.status !== 'needs_review') {\n      throw new Error(`Content has already been reviewed: ${path}`);\n    }\n\n    // Score the content with AI\n    const content = await this.scanner.readContent(path);\n    const analysis = await this.ai.scoreContent(content);\n\n    // Update entry with scores and proper status\n    const updatedEntry: ContentEntry = {\n      ...entry,\n      currentScores: analysis.scores,\n      lastReviewDate: new Date().toISOString(),\n      status: this.determineStatus(analysis.scores),\n      reviewHistory: [{\n        date: new Date().toISOString(),\n        scores: analysis.scores,\n        improvements: []\n      }]\n    };\n\n    await this.db.updateEntry(path, () => updatedEntry);\n    await this.db.save();\n  }\n\n  /**\n   * Get the entry with the lowest average score (excludes unreviewed content)\n   */\n  getWorstScoringContent(): string | null {\n    const database = this.db.getData();\n    let worstScore = Infinity;\n    let worstPath: string | null = null;\n\n    for (const [path, entry] of Object.entries(database.entries)) {\n      // Skip content that meets targets or hasn't been reviewed yet\n      if (entry.status === 'meets_targets' || entry.status === 'needs_review') continue;\n\n      const avgScore = Object.values(entry.currentScores).reduce((a, b) => a + b, 0) / \n        Object.keys(entry.currentScores).length;\n\n      // Also skip content with zero scores (unreviewed)\n      if (avgScore === 0) continue;\n\n      if (avgScore < worstScore) {\n        worstScore = avgScore;\n        worstPath = path;\n      }\n    }\n\n    return worstPath;\n  }\n\n  /**\n   * Improve content at the specified path\n   */\n  async improveContent(path: string): Promise<void> {\n    const database = this.db.getData();\n    const entry = database.entries[path];\n\n    if (!entry) {\n      throw new Error(`No content found at path: ${path}`);\n    }\n\n    // Read current content\n    const content = await this.scanner.readContent(path);\n    \n    // Get current analysis\n    const analysis = await this.ai.scoreContent(content);\n    \n    // Generate improved content\n    const improvedContent = await this.ai.improveContent(content, analysis);\n    \n    // Score the improved content\n    const newAnalysis = await this.ai.scoreContent(improvedContent);\n    \n    // Update the content file\n    await fs.writeFile(path, improvedContent, 'utf-8');\n    \n    // Update database entry\n    await this.db.updateEntry(path, (entry: ContentEntry | undefined) => {\n      if (!entry) {\n        throw new Error(`Entry not found for path: ${path}`);\n      }\n      return {\n        ...entry,\n        currentScores: newAnalysis.scores,\n        lastReviewDate: new Date().toISOString(),\n        improvementIterations: entry.improvementIterations + 1,\n        status: this.determineStatus(newAnalysis.scores),\n        reviewHistory: [\n          ...entry.reviewHistory,\n          {\n            date: new Date().toISOString(),\n            scores: newAnalysis.scores,\n            improvements: Object.values(analysis.analysis).flatMap(a => a.suggestions)\n          }\n        ]\n      };\n    });\n  }\n\n  /**\n   * Determine content status based on scores\n   */\n  private determineStatus(scores: QualityDimensions): ContentEntry['status'] {\n    const avgScore = Object.values(scores).reduce((a, b) => a + b, 0) / \n      Object.keys(scores).length;\n\n    if (avgScore >= 8.5) return 'meets_targets';\n    if (avgScore >= 7.0) return 'needs_improvement';\n    return 'needs_review';\n  }\n}\n\n/**\n * Factory function for creating Shakespeare instances\n */\nexport function createShakespeare(rootDir?: string, dbPath?: string, options?: ShakespeareOptions): Shakespeare {\n  return new Shakespeare(rootDir, dbPath, options);\n}\n\n/**\n * Convenience factory functions for different frameworks\n */\nexport const ShakespeareFactory = {\n  /** Create Shakespeare for Astro projects with content collections */\n  forAstro: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) => \n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'astro' }),\n  \n  /** Create Shakespeare for Next.js projects */\n  forNextJS: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'nextjs' }),\n  \n  /** Create Shakespeare for Gatsby projects */\n  forGatsby: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'gatsby' }),\n  \n  /** Create Shakespeare with custom content collection configuration */\n  forCustom: (contentConfig: ContentCollectionConfig, rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: contentConfig })\n};\n", "#!/usr/bin/env node\n\nimport { Shakespeare } from '..';\nimport path from 'path';\n\nasync function main() {\n  const contentDir = process.env.CONTENT_DIR || path.join(process.cwd(), 'content');\n  const dbPath = process.env.DB_PATH || path.join(process.cwd(), '.shakespeare', 'content-db.json');\n\n  const shakespeare = new Shakespeare(contentDir, dbPath);\n  await shakespeare.initialize();\n  await shakespeare.updateContentIndex();\n\n  console.log('Content index updated successfully');\n}\n\nmain().catch(console.error);\n"],
  "mappings": "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",
  "names": ["fs", "path", "path", "fs", "path", "fs", "entry", "path"]
}
