{
  "version": 3,
  "sources": ["../../src/utils/scanner.ts", "../../src/types/interfaces.ts", "../../src/utils/database.ts", "../../src/utils/constants.ts", "../../src/utils/goose.ts", "../../src/utils/ai.ts", "../../src/index.ts", "../../src/scripts/improveContent.ts"],
  "sourcesContent": ["import fs from 'fs/promises';\nimport path from 'path';\nimport { IContentScanner, ContentCollectionConfig, CONTENT_COLLECTIONS } from '@/types/interfaces';\n\n/**\n * Content scanner with configurable content collection support\n */\nexport class ContentScanner implements IContentScanner {\n  private config: ContentCollectionConfig;\n  private rootDir: string;\n\n  constructor(rootDir: string = process.cwd(), config?: ContentCollectionConfig | keyof typeof CONTENT_COLLECTIONS) {\n    this.rootDir = rootDir;\n    \n    // Handle different config types\n    if (typeof config === 'string') {\n      this.config = CONTENT_COLLECTIONS[config] as ContentCollectionConfig;\n    } else if (config) {\n      this.config = config;\n    } else {\n      // Default to Astro content collections\n      this.config = CONTENT_COLLECTIONS.astro as ContentCollectionConfig;\n    }\n  }\n\n  /**\n   * Scan for content files based on configuration\n   */\n  async scanContent(): Promise<string[]> {\n    const contentDir = path.resolve(this.rootDir, this.config.baseDir);\n    \n    // Check if content directory exists\n    try {\n      await fs.access(contentDir);\n    } catch {\n      throw new Error(`Content directory not found: ${contentDir}. Make sure the directory exists or configure a different baseDir.`);\n    }\n\n    const contentFiles: string[] = [];\n    \n    const scan = async (dir: string, relativePath: string = ''): Promise<void> => {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n        const relativeFilePath = path.join(relativePath, entry.name);\n        \n        if (entry.isDirectory()) {\n          await scan(fullPath, relativeFilePath);\n        } else if (entry.isFile()) {\n          // Check if file matches include patterns\n          const shouldInclude = this.matchesPatterns(relativeFilePath, this.config.include);\n          const shouldExclude = this.config.exclude && this.matchesPatterns(relativeFilePath, this.config.exclude);\n          \n          if (shouldInclude && !shouldExclude) {\n            contentFiles.push(fullPath);\n          }\n        }\n      }\n    };\n\n    await scan(contentDir);\n    return contentFiles.sort();\n  }\n\n  /**\n   * Check if a file path matches any of the given glob-like patterns\n   */\n  private matchesPatterns(filePath: string, patterns: readonly string[]): boolean {\n    return patterns.some(pattern => this.matchesPattern(filePath, pattern));\n  }\n\n  /**\n   * Simple glob pattern matching (supports ** and * wildcards)\n   */\n  private matchesPattern(filePath: string, pattern: string): boolean {\n    // Normalize path separators\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\n    const normalizedPattern = pattern.replace(/\\\\/g, '/');\n    \n    // Convert glob pattern to regex\n    let regexPattern = normalizedPattern\n      .replace(/\\./g, '\\\\.')     // Escape dots first\n      .replace(/\\*\\*\\//g, '___DOUBLESTARSLASH___')  // Handle **/ first\n      .replace(/\\*\\*/g, '___DOUBLESTAR___')  // Handle remaining ** \n      .replace(/\\*/g, '[^/]*')   // * matches any filename characters except /\n      .replace(/___DOUBLESTARSLASH___/g, '(?:.*/)?') // **/ matches any path including / (optional for root level)\n      .replace(/___DOUBLESTAR___/g, '(?:.*/)?'); // ** matches any path including / (optional for root level)\n    \n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(normalizedPath);\n  }\n\n  /**\n   * Read content of a markdown file\n   */\n  async readContent(filePath: string): Promise<string> {\n    return fs.readFile(filePath, 'utf-8');\n  }\n}\n", "import { ContentDatabase, ContentEntry } from './content';\nimport { AIContentAnalysis } from '../utils/ai';\n\n/**\n * Content collection configuration for different frameworks\n */\nexport interface ContentCollectionConfig {\n  /** Base directory to scan for content */\n  baseDir: string;\n  /** File patterns to include (glob patterns) */\n  include: readonly string[];\n  /** File patterns to exclude (glob patterns) */\n  exclude?: readonly string[];\n  /** Framework-specific settings */\n  framework?: 'astro' | 'nextjs' | 'gatsby' | 'custom';\n}\n\n/**\n * Predefined content collection configurations\n */\nexport const CONTENT_COLLECTIONS = {\n  astro: {\n    baseDir: 'src/content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/index.md', '**/README.md'],\n    framework: 'astro' as const\n  },\n  nextjs: {\n    baseDir: 'content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/README.md'],\n    framework: 'nextjs' as const\n  },\n  gatsby: {\n    baseDir: 'content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/README.md'],\n    framework: 'gatsby' as const\n  },\n  custom: (baseDir: string, include: string[] = ['**/*.md'], exclude: string[] = []) => ({\n    baseDir,\n    include,\n    exclude,\n    framework: 'custom' as const\n  })\n} as const;\n\n/**\n * AI model configuration options\n */\nexport interface AIModelOptions {\n  /** Provider name (e.g., 'openai', 'anthropic', 'google') */\n  provider?: string;\n  /** Specific model name (e.g., 'gpt-4o-mini', 'claude-3-5-haiku') */\n  model?: string;\n  /** Temperature for response generation */\n  temperature?: number;\n  /** Maximum tokens for response */\n  maxTokens?: number;\n  /** Custom configuration for specific providers */\n  providerConfig?: Record<string, any>;\n}\n\n/**\n * Cost tracking information for AI operations\n */\nexport interface AICostInfo {\n  /** Provider used for the operation */\n  provider: string;\n  /** Model used for the operation */\n  model: string;\n  /** Input tokens consumed */\n  inputTokens: number;\n  /** Output tokens generated */\n  outputTokens: number;\n  /** Total cost in USD */\n  totalCost: number;\n  /** Timestamp of the operation */\n  timestamp: string;\n}\n\n/**\n * Response from AI operations including cost tracking\n */\nexport interface AIResponse {\n  /** The generated text response */\n  content: string;\n  /** Cost and usage information */\n  costInfo: AICostInfo;\n}\n\n/**\n * Interface for AI interaction with multi-model and cost tracking support\n */\nexport interface IAI {\n  /** Original method for backward compatibility */\n  prompt(prompt: string): Promise<string>;\n  /** Enhanced method with model selection and cost tracking */\n  promptWithOptions(prompt: string, options?: AIModelOptions): Promise<AIResponse>;\n  /** Estimate cost before making a request */\n  estimateCost(prompt: string, options?: AIModelOptions): Promise<number>;\n}\n\n/**\n * Interface for file system operations\n */\nexport interface IFileSystem {\n  readFile(path: string, encoding?: BufferEncoding): Promise<string>;\n  writeFile(path: string, data: string, encoding?: BufferEncoding): Promise<void>;\n  readdir(path: string, options?: { withFileTypes?: boolean }): Promise<any[]>;\n  mkdir(path: string, options?: { recursive?: boolean }): Promise<void>;\n}\n\n/**\n * Interface for content scanning\n */\nexport interface IContentScanner {\n  scanContent(): Promise<string[]>;\n  readContent(filePath: string): Promise<string>;\n}\n\n/**\n * Interface for database operations\n */\nexport interface IContentDatabase {\n  load(): Promise<ContentDatabase>;\n  save(): Promise<void>;\n  getData(): ContentDatabase;\n  updateEntry(entryPath: string, updateFn: (entry: ContentEntry | undefined) => ContentEntry): Promise<void>;\n}\n\n/**\n * Scoring strategy configuration\n */\nexport interface ScoringStrategy {\n  /** Quality dimension being scored */\n  dimension: 'readability' | 'seoScore' | 'technicalAccuracy' | 'engagement' | 'contentDepth';\n  /** Preferred model for this dimension (optional - uses default if not specified) */\n  preferredModel?: AIModelOptions;\n  /** Cost budget for this scoring operation */\n  maxCostUSD?: number;\n}\n\n/**\n * Enhanced content analysis including cost information\n */\nexport interface EnhancedAIContentAnalysis {\n  /** The analysis results */\n  analysis: AIContentAnalysis;\n  /** Total cost for all scoring operations */\n  totalCost: number;\n  /** Cost breakdown per dimension */\n  costBreakdown: Record<string, AICostInfo>;\n}\n\n/**\n * Interface for AI content scoring with cost optimization\n */\nexport interface IContentScorer {\n  /** Original methods for backward compatibility */\n  scoreContent(content: string): Promise<AIContentAnalysis>;\n  improveContent(content: string, analysis: AIContentAnalysis): Promise<string>;\n  \n  /** Enhanced methods with cost tracking and model selection */\n  scoreContentWithCosts(content: string, strategies?: ScoringStrategy[]): Promise<EnhancedAIContentAnalysis>;\n  improveContentWithCosts(content: string, analysis: AIContentAnalysis, options?: AIModelOptions): Promise<AIResponse>;\n  \n  /** Batch operations for cost optimization */\n  scoreContentBatch(contentList: string[], strategies?: ScoringStrategy[]): Promise<EnhancedAIContentAnalysis[]>;\n  \n  /** Cost estimation for operations */\n  estimateScoringCost(content: string, strategies?: ScoringStrategy[]): Promise<number>;\n  estimateImprovementCost(content: string, analysis: AIContentAnalysis, options?: AIModelOptions): Promise<number>;\n}\n\n/**\n * Workflow-specific configuration stored in content-db.json\n */\nexport interface WorkflowConfig {\n  /** Content collection type (auto-detected if not specified) */\n  contentCollection?: keyof typeof CONTENT_COLLECTIONS | 'custom';\n  \n  /** Enable verbose logging */\n  verbose?: boolean;\n  \n  /** Model configuration for different workflow types */\n  models?: {\n    /** Model for content review/scoring operations */\n    review?: string;\n    /** Model for content improvement operations */\n    improve?: string;\n    /** Model for content generation operations */\n    generate?: string;\n  };\n  \n  /** Provider configuration for different workflow types */\n  providers?: {\n    /** Provider for content review/scoring operations */\n    review?: string;\n    /** Provider for content improvement operations */\n    improve?: string;\n    /** Provider for content generation operations */\n    generate?: string;\n  };\n  \n  /** Workflow-specific settings */\n  workflows?: {\n    discover?: {\n      /** Whether to reset existing entries when discovering */\n      resetExisting?: boolean;\n      /** Whether to automatically initialize database */\n      autoInit?: boolean;\n    };\n    review?: {\n      /** Batch size for review operations */\n      batchSize?: number;\n      /** Whether to estimate costs before running */\n      estimateCosts?: boolean;\n      /** Whether to retry failed operations */\n      retryFailures?: boolean;\n    };\n    improve?: {\n      /** Maximum number of items to improve */\n      maxCount?: number;\n      /** Whether to require review before improvement */\n      requireReviewFirst?: boolean;\n      /** Minimum score threshold to trigger improvement */\n      targetThreshold?: number;\n    };\n    complete?: {\n      /** Number of items to improve in complete workflow */\n      improveCount?: number;\n      /** Whether to run discovery as part of complete workflow */\n      runDiscovery?: boolean;\n    };\n  };\n}", "import fs from 'fs/promises';\nimport path from 'path';\nimport { ContentDatabase, ContentEntry } from '@/types/content';\nimport { IContentDatabase } from '@/types/interfaces';\n\nexport { ContentDatabase as ContentDatabaseType } from '@/types/content';\n\n/**\n * Database handler for content tracking\n */\nexport class ContentDatabaseHandler implements IContentDatabase {\n  private dbPath: string;\n  private dbDir: string;\n  private data: ContentDatabase = {\n    lastUpdated: new Date().toISOString(),\n    entries: {}\n  };\n\n  constructor(dbPath: string) {\n    this.dbPath = dbPath;\n    this.dbDir = path.dirname(dbPath);\n  }\n\n  /**\n   * Convert absolute path to relative path from database directory\n   */\n  private toRelativePath(absolutePath: string): string {\n    return path.relative(this.dbDir, absolutePath);\n  }\n\n  /**\n   * Convert relative path to absolute path from database directory\n   */\n  private toAbsolutePath(relativePath: string): string {\n    return path.resolve(this.dbDir, relativePath);\n  }\n\n  /**\n   * Load the database from disk\n   */\n  async load(): Promise<ContentDatabase> {\n    try {\n      const content = await fs.readFile(this.dbPath, 'utf-8');\n      this.data = JSON.parse(content);\n      \n      // Convert stored relative paths to absolute paths for internal use\n      const normalizedEntries: { [key: string]: ContentEntry } = {};\n      for (const [relativePath, entry] of Object.entries(this.data.entries)) {\n        const absolutePath = this.toAbsolutePath(relativePath);\n        normalizedEntries[absolutePath] = {\n          ...entry,\n          path: absolutePath // Ensure entry.path is also absolute\n        };\n      }\n      this.data.entries = normalizedEntries;\n      \n      return this.data;\n    } catch (error) {\n      // If file doesn't exist, create new database\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        await this.save();\n        return this.data;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Save the database to disk\n   */\n  async save(): Promise<void> {\n    this.data.lastUpdated = new Date().toISOString();\n    \n    // Convert absolute paths to relative paths for storage\n    const storageData: ContentDatabase = {\n      ...this.data,\n      entries: {}\n    };\n    \n    for (const [absolutePath, entry] of Object.entries(this.data.entries)) {\n      const relativePath = this.toRelativePath(absolutePath);\n      storageData.entries[relativePath] = {\n        ...entry,\n        path: relativePath // Store relative path in entry.path as well\n      };\n    }\n    \n    await fs.writeFile(this.dbPath, JSON.stringify(storageData, null, 2));\n  }\n\n  /**\n   * Get the current database state\n   */\n  getData(): ContentDatabase {\n    return this.data;\n  }\n\n  /**\n   * Update an entry in the database\n   */\n  async updateEntry(entryPath: string, updateFn: (entry: ContentEntry | undefined) => ContentEntry): Promise<void> {\n    this.data.entries[entryPath] = updateFn(this.data.entries[entryPath]);\n    await this.save();\n  }\n}\n", "import { QualityDimensions } from '../types/content';\n\n/**\n * Default target scores for content quality\n */\nexport const DEFAULT_TARGET_SCORES: QualityDimensions = {\n  readability: 8.0,\n  seoScore: 8.5,\n  technicalAccuracy: 9.0,\n  engagement: 8.0,\n  contentDepth: 8.5\n};\n\n/**\n * Configuration for content improvement\n */\nexport const IMPROVEMENT_CONFIG = {\n  maxIterations: 3,\n  minScoreImprovement: 0.5,\n  scoreThreshold: 7.0\n};\n", "import { spawn } from 'child_process';\nimport { IAI, AIModelOptions, AIResponse, AICostInfo } from '@/types/interfaces';\n\n/**\n * Cost per token (in USD) for different providers/models\n * These are approximate costs and should be updated based on current pricing\n */\nconst MODEL_COSTS = {\n  // OpenAI pricing (per 1M tokens)\n  'openai/gpt-4o-mini': { input: 0.00015, output: 0.0006 },\n  'openai/gpt-4o': { input: 0.005, output: 0.015 },\n  \n  // Anthropic pricing (per 1M tokens)  \n  'anthropic/claude-3-5-haiku': { input: 0.0008, output: 0.004 },\n  'anthropic/claude-3-5-sonnet': { input: 0.003, output: 0.015 },\n  \n  // Google pricing (per 1M tokens)\n  'google/gemini-1.5-flash': { input: 0.000075, output: 0.0003 },\n  'google/gemini-1.5-pro': { input: 0.00125, output: 0.005 },\n  \n  // Groq pricing (per 1M tokens) - very fast inference\n  'groq/llama-3.1-70b': { input: 0.00059, output: 0.00079 },\n  'groq/llama-3.1-8b': { input: 0.00005, output: 0.00008 },\n  \n  // DeepInfra pricing (per 1M tokens) - cost effective\n  'deepinfra/llama-3.1-70b': { input: 0.00052, output: 0.00075 },\n  'deepinfra/deepseek-chat': { input: 0.00014, output: 0.00028 }\n} as const;\n\n/**\n * Default models for cost optimization by task type\n */\nconst DEFAULT_MODELS_BY_TASK = {\n  // Light tasks - use cheapest models\n  scoring: { provider: 'google', model: 'gemini-1.5-flash' },\n  analysis: { provider: 'groq', model: 'llama-3.1-8b' },\n  // Medium tasks - balance cost and quality\n  improvement: { provider: 'anthropic', model: 'claude-3-5-haiku' },\n  // Heavy tasks - use best models\n  generation: { provider: 'anthropic', model: 'claude-3-5-sonnet' }\n} as const;\n\n/**\n * Enhanced Goose AI interaction handler with multi-model support and cost tracking\n */\nexport class GooseAI implements IAI {\n  private gooseCommand: string;\n  private cwd: string;\n  private defaultOptions: AIModelOptions;\n\n  constructor(cwd: string = process.cwd(), defaultOptions: AIModelOptions = {}) {\n    this.gooseCommand = 'goose'; // Assumes goose is in PATH\n    this.cwd = cwd;\n    this.defaultOptions = defaultOptions;\n  }\n\n  /**\n   * Send a prompt to Goose and get the response using headless mode (backward compatibility)\n   */\n  async prompt(prompt: string): Promise<string> {\n    const response = await this.promptWithOptions(prompt);\n    return response.content;\n  }\n\n  /**\n   * Enhanced prompt method with model selection and cost tracking\n   */\n  async promptWithOptions(prompt: string, options?: AIModelOptions): Promise<AIResponse> {\n    const startTime = Date.now();\n    const finalOptions = { ...this.defaultOptions, ...options };\n    \n    // Build goose command arguments with provider and model selection\n    const args = ['run', '--no-session', '--quiet'];\n    \n    if (finalOptions.provider) {\n      args.push('--provider', finalOptions.provider);\n    }\n    \n    if (finalOptions.model) {\n      args.push('--model', finalOptions.model);\n    }\n    \n    // Always add --text and prompt at the end\n    args.push('--text', prompt);\n\n    return new Promise((resolve, reject) => {\n      const goose = spawn(this.gooseCommand, args, {\n        cwd: this.cwd,\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n\n      let output = '';\n      let error = '';\n\n      goose.stdout.on('data', (data) => {\n        output += data.toString();\n      });\n\n      goose.stderr.on('data', (data) => {\n        error += data.toString();\n      });\n\n      goose.on('close', (code) => {\n        if (code !== 0) {\n          // Enhanced error reporting with more diagnostic info\n          const errorMsg = [\n            `Goose failed with exit code ${code}`,\n            error ? `STDERR: ${error}` : 'STDERR: (empty)',\n            output ? `STDOUT: ${output.substring(0, 200)}...` : 'STDOUT: (empty)',\n            `Command: ${this.gooseCommand} ${args.join(' ')}`,\n            `Prompt length: ${prompt.length} chars`\n          ].join('\\n');\n          reject(new Error(errorMsg));\n        } else {\n          const content = output.trim();\n          const costInfo = this.calculateCostInfo(\n            prompt, \n            content, \n            finalOptions,\n            startTime\n          );\n          \n          resolve({\n            content,\n            costInfo\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Estimate cost before making a request\n   */\n  async estimateCost(prompt: string, options?: AIModelOptions): Promise<number> {\n    const finalOptions = { ...this.defaultOptions, ...options };\n    const inputTokens = this.estimateTokens(prompt);\n    const outputTokens = Math.min(inputTokens * 2, 4000); // Estimate output as 2x input, capped\n    \n    return this.calculateCostFromTokens(inputTokens, outputTokens, finalOptions);\n  }\n\n  /**\n   * Calculate cost information for a completed operation\n   */\n  private calculateCostInfo(\n    prompt: string, \n    response: string, \n    options: AIModelOptions,\n    startTime: number\n  ): AICostInfo {\n    const inputTokens = this.estimateTokens(prompt);\n    const outputTokens = this.estimateTokens(response);\n    const totalCost = this.calculateCostFromTokens(inputTokens, outputTokens, options);\n    \n    return {\n      provider: options.provider || 'default',\n      model: options.model || 'default',\n      inputTokens,\n      outputTokens,\n      totalCost,\n      timestamp: new Date(startTime).toISOString()\n    };\n  }\n\n  /**\n   * Calculate cost from token counts and model options\n   */\n  private calculateCostFromTokens(\n    inputTokens: number, \n    outputTokens: number, \n    options: AIModelOptions\n  ): number {\n    const modelKey = `${options.provider || 'openai'}/${options.model || 'gpt-4o-mini'}`;\n    const pricing = MODEL_COSTS[modelKey as keyof typeof MODEL_COSTS];\n    \n    if (!pricing) {\n      // Default to GPT-4o-mini pricing if model not found\n      const defaultPricing = MODEL_COSTS['openai/gpt-4o-mini'];\n      return (inputTokens * defaultPricing.input + outputTokens * defaultPricing.output) / 1000000;\n    }\n    \n    return (inputTokens * pricing.input + outputTokens * pricing.output) / 1000000;\n  }\n\n  /**\n   * Estimate token count for text (rough approximation)\n   */\n  private estimateTokens(text: string): number {\n    // Rough approximation: 4 characters per token on average\n    return Math.ceil(text.length / 4);\n  }\n\n  /**\n   * Get optimal model for a specific task type\n   */\n  getOptimalModelForTask(taskType: keyof typeof DEFAULT_MODELS_BY_TASK): AIModelOptions {\n    return DEFAULT_MODELS_BY_TASK[taskType];\n  }\n}\n", "import { GooseAI } from '@/utils/goose';\nimport { QualityDimensions } from '@/types/content';\nimport { IAI, IContentScorer, ScoringStrategy, EnhancedAIContentAnalysis, AIModelOptions, AIResponse, AICostInfo } from '@/types/interfaces';\n\nexport interface AIScoreResponse {\n  score: number;\n  reasoning: string;\n  suggestions?: string[];\n}\n\nexport interface AIContentAnalysis {\n  scores: QualityDimensions;\n  analysis: {\n    [K in keyof QualityDimensions]: {\n      reasoning: string;\n      suggestions: string[];\n    }\n  };\n}\n\n/**\n * Prompts for content analysis\n */\nexport const ANALYSIS_PROMPTS = {\n  readability: `\n    Analyze the following content for readability. Consider:\n    - Sentence structure and length\n    - Vocabulary level and consistency\n    - Paragraph organization\n    - Use of transitions\n    - Clear and concise explanations\n    \n    Score from 0-10 where:\n    0-3: Difficult to read, needs major revision\n    4-6: Somewhat readable but needs improvement\n    7-8: Good readability\n    9-10: Excellent, clear and engaging\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `,\n\n  seoScore: `\n    Evaluate the following content for SEO effectiveness. Consider:\n    - Keyword usage and placement\n    - Meta description potential\n    - Header structure and organization\n    - Internal/external linking opportunities\n    - Content length and depth\n    \n    Score from 0-10 where:\n    0-3: Poor SEO optimization\n    4-6: Basic SEO implementation\n    7-8: Good SEO practices\n    9-10: Excellent SEO optimization\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `,\n\n  technicalAccuracy: `\n    Review the following content for technical accuracy. Consider:\n    - Factual correctness\n    - Code examples (if any)\n    - Technical terminology usage\n    - Up-to-date information\n    - Technical depth appropriate for the topic\n    \n    Score from 0-10 where:\n    0-3: Contains significant technical errors\n    4-6: Some technical inaccuracies\n    7-8: Generally accurate with minor issues\n    9-10: Highly accurate and well-researched\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `,\n\n  engagement: `\n    Evaluate the content's engagement level. Consider:\n    - Writing style and tone\n    - Use of examples and analogies\n    - Reader interaction elements\n    - Story-telling elements\n    - Call-to-action effectiveness\n    \n    Score from 0-10 where:\n    0-3: Dry and unengaging\n    4-6: Somewhat engaging but could improve\n    7-8: Good engagement level\n    9-10: Highly engaging and compelling\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `,\n\n  contentDepth: `\n    Analyze the content's depth and comprehensiveness. Consider:\n    - Topic coverage breadth\n    - Supporting evidence and examples\n    - Explanation thoroughness\n    - Context and background information\n    - Advanced concept handling\n    \n    Score from 0-10 where:\n    0-3: Surface level only\n    4-6: Basic coverage with some depth\n    7-8: Good depth with most aspects covered\n    9-10: Comprehensive and thorough coverage\n    \n    Provide:\n    1. Numeric score (0-10)\n    2. Brief reasoning for the score\n    3. Specific suggestions for improvement\n    \n    Content to analyze:\n    {content}\n    `\n};\n\n/**\n * Prompt for content improvement\n */\nexport const IMPROVEMENT_PROMPT = `\nYou are a content improvement specialist. Review the following content and its quality analysis.\nFocus on the dimensions that scored lowest and provide specific improvements.\n\nCurrent scores and analysis:\n{analysis}\n\nOriginal content:\n{content}\n\nPlease provide:\n1. Improved version of the content\n2. Summary of changes made\n3. Expected impact on quality scores\n\nMake sure to maintain any technical accuracy while improving readability and engagement.\nPreserve the original meaning and intent while enhancing the presentation and effectiveness.\n`;\n\n/**\n * Parse Goose response to extract score, reasoning, and suggestions\n */\nfunction parseGooseResponse(response: string): AIScoreResponse {\n  // Example response parsing - adjust based on actual Goose output format\n  const lines = response.split('\\n').map(l => l.trim()).filter(Boolean);\n  \n  let score = 7.0; // Default score\n  let reasoning = '';\n  const suggestions: string[] = [];\n  \n  for (const line of lines) {\n    if (line.match(/^\\d+(\\.\\d+)?$/)) {\n      score = parseFloat(line);\n    } else if (line.startsWith('- ')) {\n      suggestions.push(line.slice(2));\n    } else {\n      reasoning = line;\n    }\n  }\n  \n  return {\n    score,\n    reasoning,\n    suggestions\n  };\n}\n\n/**\n * Options for AIScorer constructor\n */\nexport interface AIScorerOptions {\n  ai?: IAI;\n}\n\n/**\n * AI scoring system implementation with cost optimization\n */\nexport class AIScorer implements IContentScorer {\n  private ai: IAI;\n\n  constructor(options: AIScorerOptions = {}) {\n    this.ai = options.ai ?? new GooseAI();\n  }\n\n  /**\n   * Score content across all quality dimensions\n   */\n  async scoreContent(content: string): Promise<AIContentAnalysis> {\n    const analysis: Partial<AIContentAnalysis> = {\n      scores: {} as QualityDimensions,\n      analysis: {} as AIContentAnalysis['analysis']\n    };\n\n    // Score each dimension\n    for (const [dimension, promptTemplate] of Object.entries(ANALYSIS_PROMPTS)) {\n      const prompt = promptTemplate.replace('{content}', content);\n      const result = await this.scoreDimension(content, prompt);\n      \n      // Update scores and analysis\n      (analysis.scores as any)[dimension] = result.score;\n      (analysis.analysis as any)[dimension] = {\n        reasoning: result.reasoning,\n        suggestions: result.suggestions || []\n      };\n    }\n\n    return analysis as AIContentAnalysis;\n  }\n\n  /**\n   * Score content for a specific dimension\n   */\n  private async scoreDimension(content: string, prompt: string): Promise<AIScoreResponse> {\n    try {\n      const response = await this.ai.prompt(prompt);\n      return parseGooseResponse(response);\n    } catch (error) {\n      console.error('Error scoring content:', error);\n      return {\n        score: 5.0,\n        reasoning: 'Error during scoring process',\n        suggestions: ['Retry scoring']\n      };\n    }\n  }\n\n  /**\n   * Generate improved content based on analysis\n   */\n  async improveContent(content: string, analysis: AIContentAnalysis): Promise<string> {\n    const response = await this.improveContentWithCosts(content, analysis);\n    return response.content;\n  }\n\n  /**\n   * Enhanced scoring with cost tracking and model selection\n   */\n  async scoreContentWithCosts(content: string, strategies?: ScoringStrategy[]): Promise<EnhancedAIContentAnalysis> {\n    const analysis: Partial<AIContentAnalysis> = {\n      scores: {} as QualityDimensions,\n      analysis: {} as AIContentAnalysis['analysis']\n    };\n    \n    const costBreakdown: Record<string, AICostInfo> = {};\n    let totalCost = 0;\n\n    // Create default strategies if none provided - optimized for cost\n    const defaultStrategies: ScoringStrategy[] = strategies || [\n      { dimension: 'readability', preferredModel: { provider: 'google', model: 'gemini-1.5-flash' } },\n      { dimension: 'seoScore', preferredModel: { provider: 'google', model: 'gemini-1.5-flash' } },\n      { dimension: 'technicalAccuracy', preferredModel: { provider: 'groq', model: 'llama-3.1-8b' } },\n      { dimension: 'engagement', preferredModel: { provider: 'google', model: 'gemini-1.5-flash' } },\n      { dimension: 'contentDepth', preferredModel: { provider: 'groq', model: 'llama-3.1-8b' } }\n    ];\n\n    // Score each dimension with cost tracking\n    for (const strategy of defaultStrategies) {\n      const promptTemplate = ANALYSIS_PROMPTS[strategy.dimension];\n      const prompt = promptTemplate.replace('{content}', content);\n      \n      try {\n        const result = await this.scoreDimensionWithCost(prompt, strategy.preferredModel);\n        \n        // Update scores and analysis\n        (analysis.scores as any)[strategy.dimension] = result.response.score;\n        (analysis.analysis as any)[strategy.dimension] = {\n          reasoning: result.response.reasoning,\n          suggestions: result.response.suggestions || []\n        };\n        \n        // Track costs\n        costBreakdown[strategy.dimension] = result.costInfo;\n        totalCost += result.costInfo.totalCost;\n        \n      } catch (error) {\n        console.error(`Error scoring ${strategy.dimension}:`, error);\n        // Use default values on error\n        (analysis.scores as any)[strategy.dimension] = 5.0;\n        (analysis.analysis as any)[strategy.dimension] = {\n          reasoning: 'Error during scoring process',\n          suggestions: ['Retry scoring']\n        };\n      }\n    }\n\n    return {\n      analysis: analysis as AIContentAnalysis,\n      totalCost,\n      costBreakdown\n    };\n  }\n\n  /**\n   * Enhanced content improvement with cost tracking\n   */\n  async improveContentWithCosts(content: string, analysis: AIContentAnalysis, options?: AIModelOptions): Promise<AIResponse> {\n    const analysisStr = JSON.stringify(analysis, null, 2);\n    const prompt = IMPROVEMENT_PROMPT\n      .replace('{analysis}', analysisStr)\n      .replace('{content}', content);\n\n    // Use provided options or let GooseAI use its configured defaults\n    // Don't force any provider/model defaults here - respect user configuration\n    const finalOptions = options;\n\n    try {\n      if ('promptWithOptions' in this.ai && typeof this.ai.promptWithOptions === 'function') {\n        const response = await (this.ai as any).promptWithOptions(prompt, finalOptions);\n        // Extract the improved content from the response\n        const sections = response.content.split('\\n\\n');\n        return {\n          content: sections[0] || content,\n          costInfo: response.costInfo\n        };\n      } else {\n        // Fallback for IAI implementations without cost tracking\n        const responseText = await this.ai.prompt(prompt);\n        const sections = responseText.split('\\n\\n');\n        return {\n          content: sections[0] || content,\n          costInfo: {\n            provider: finalOptions?.provider || 'unknown',\n            model: finalOptions?.model || 'unknown',\n            inputTokens: Math.ceil(prompt.length / 4),\n            outputTokens: Math.ceil(responseText.length / 4),\n            totalCost: 0, // Cannot calculate without enhanced AI\n            timestamp: new Date().toISOString()\n          }\n        };\n      }\n    } catch (error) {\n      console.error('Error improving content:', error);\n      return {\n        content,\n        costInfo: {\n          provider: finalOptions?.provider || 'unknown',\n          model: finalOptions?.model || 'unknown',\n          inputTokens: 0,\n          outputTokens: 0,\n          totalCost: 0,\n          timestamp: new Date().toISOString()\n        }\n      };\n    }\n  }\n\n  /**\n   * Batch scoring for cost optimization\n   */\n  async scoreContentBatch(contentList: string[], strategies?: ScoringStrategy[]): Promise<EnhancedAIContentAnalysis[]> {\n    // For now, process sequentially. In the future, this could be enhanced with actual batch API calls\n    const results: EnhancedAIContentAnalysis[] = [];\n    \n    for (const content of contentList) {\n      const result = await this.scoreContentWithCosts(content, strategies);\n      results.push(result);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Estimate cost for scoring operation\n   */\n  async estimateScoringCost(content: string, strategies?: ScoringStrategy[]): Promise<number> {\n    if (!('estimateCost' in this.ai) || typeof this.ai.estimateCost !== 'function') {\n      return 0; // Cannot estimate without enhanced AI\n    }\n\n    const defaultStrategies: ScoringStrategy[] = strategies || [\n      { dimension: 'readability', preferredModel: { provider: 'google', model: 'gemini-1.5-flash' } },\n      { dimension: 'seoScore', preferredModel: { provider: 'google', model: 'gemini-1.5-flash' } },\n      { dimension: 'technicalAccuracy', preferredModel: { provider: 'groq', model: 'llama-3.1-8b' } },\n      { dimension: 'engagement', preferredModel: { provider: 'google', model: 'gemini-1.5-flash' } },\n      { dimension: 'contentDepth', preferredModel: { provider: 'groq', model: 'llama-3.1-8b' } }\n    ];\n\n    let totalEstimatedCost = 0;\n    \n    for (const strategy of defaultStrategies) {\n      const promptTemplate = ANALYSIS_PROMPTS[strategy.dimension];\n      const prompt = promptTemplate.replace('{content}', content);\n      const cost = await (this.ai as any).estimateCost(prompt, strategy.preferredModel);\n      totalEstimatedCost += cost;\n    }\n    \n    return totalEstimatedCost;\n  }\n\n  /**\n   * Estimate cost for improvement operation\n   */\n  async estimateImprovementCost(content: string, analysis: AIContentAnalysis, options?: AIModelOptions): Promise<number> {\n    if (!('estimateCost' in this.ai) || typeof this.ai.estimateCost !== 'function') {\n      return 0; // Cannot estimate without enhanced AI\n    }\n\n    const analysisStr = JSON.stringify(analysis, null, 2);\n    const prompt = IMPROVEMENT_PROMPT\n      .replace('{analysis}', analysisStr)\n      .replace('{content}', content);\n\n    // Use provided options or let GooseAI use its configured defaults  \n    return await (this.ai as any).estimateCost(prompt, options);\n  }\n\n  /**\n   * Score a specific dimension with cost tracking\n   */\n  private async scoreDimensionWithCost(prompt: string, modelOptions?: AIModelOptions): Promise<{\n    response: AIScoreResponse;\n    costInfo: AICostInfo;\n  }> {\n    if ('promptWithOptions' in this.ai && typeof this.ai.promptWithOptions === 'function') {\n      const response = await (this.ai as any).promptWithOptions(prompt, modelOptions);\n      return {\n        response: parseGooseResponse(response.content),\n        costInfo: response.costInfo\n      };\n    } else {\n      // Fallback for basic IAI implementations\n      const responseText = await this.ai.prompt(prompt);\n      return {\n        response: parseGooseResponse(responseText),\n        costInfo: {\n          provider: modelOptions?.provider || 'unknown',\n          model: modelOptions?.model || 'unknown',\n          inputTokens: Math.ceil(prompt.length / 4),\n          outputTokens: Math.ceil(responseText.length / 4),\n          totalCost: 0,\n          timestamp: new Date().toISOString()\n        }\n      };\n    }\n  }\n}\n\n/**\n * Factory function for creating AIScorer instances\n */\nexport function createAIScorer(options?: AIScorerOptions): AIScorer {\n  return new AIScorer(options);\n}\n", "import { ContentScanner } from '@/utils/scanner';\nimport { ContentDatabaseHandler } from '@/utils/database';\nimport { DEFAULT_TARGET_SCORES } from '@/utils/constants';\nimport { ContentEntry, QualityDimensions, ContentStatus } from '@/types/content';\nimport { AIScorer, AIContentAnalysis, AIScorerOptions } from '@/utils/ai';\nimport { GooseAI } from '@/utils/goose';\nimport { IContentScanner, IContentDatabase, IContentScorer, ContentCollectionConfig, CONTENT_COLLECTIONS, AIModelOptions, WorkflowConfig } from '@/types/interfaces';\nimport path from 'path';\nimport fs from 'fs/promises';\n\nexport * from '@/types/content';\nexport * from '@/types/interfaces';\nexport { GooseAI } from '@/utils/goose';\nexport { AIScorer } from '@/utils/ai';\n\n/**\n * Options for Shakespeare constructor\n */\nexport interface ShakespeareOptions {\n  scanner?: IContentScanner;\n  database?: IContentDatabase;\n  ai?: IContentScorer;\n  /** AI model configuration for cost optimization */\n  aiOptions?: AIScorerOptions;\n  /** Default AI model options (provider, model, etc.) */\n  defaultModelOptions?: AIModelOptions;\n  /** Content collection configuration */\n  contentCollection?: ContentCollectionConfig | keyof typeof CONTENT_COLLECTIONS;\n}\n\n/**\n * High-level configuration options for simplified setup\n */\nexport interface ShakespeareConfig {\n  /** Use cost-optimized models (cheap, fast) */\n  costOptimized?: boolean;\n  /** Use quality-first models (expensive, best results) */\n  qualityFirst?: boolean;\n  /** Override specific model */\n  model?: string;\n  /** Override specific provider */\n  provider?: string;\n  /** Custom model options */\n  modelOptions?: AIModelOptions;\n  /** Enable verbose progress reporting */\n  verbose?: boolean;\n  /** Project root directory */\n  rootDir?: string;\n  /** Database path override */\n  dbPath?: string;\n  /** Content collection override */\n  contentCollection?: ContentCollectionConfig | keyof typeof CONTENT_COLLECTIONS;\n}\n\n/**\n * Result of a workflow operation\n */\nexport interface WorkflowResult {\n  /** Successfully processed items */\n  successful: string[];\n  /** Failed items with error messages */\n  failed: { path: string; error: string }[];\n  /** Summary statistics */\n  summary: {\n    total: number;\n    succeeded: number;\n    failed: number;\n    duration: number;\n  };\n}\n\nexport class Shakespeare {\n  private scanner: IContentScanner;\n  private _db: IContentDatabase;\n  private ai: IContentScorer;\n  private rootDir: string;\n  private dbPath: string;\n  private verbose: boolean = false;\n  \n  /** Configuration used to create this instance */\n  public readonly config: ShakespeareConfig;\n  \n  /** Model options being used for AI operations */\n  public readonly modelOptions?: AIModelOptions;\n\n  /**\n   * Get database instance for testing purposes\n   * @internal\n   */\n  get db(): IContentDatabase {\n    return this._db;\n  }\n\n  constructor(rootDir: string = process.cwd(), dbPath?: string, options: ShakespeareOptions = {}) {\n    this.rootDir = rootDir;\n    this.dbPath = dbPath ?? path.join(rootDir, '.shakespeare', 'content-db.json');\n    \n    // Store configuration for public access\n    this.config = {\n      rootDir,\n      dbPath,\n      contentCollection: options.contentCollection,\n      verbose: false, // Will be updated by setVerbose() if needed\n      model: options.defaultModelOptions?.model,\n      provider: options.defaultModelOptions?.provider,\n      modelOptions: options.defaultModelOptions\n    };\n    this.modelOptions = options.defaultModelOptions;\n    \n    // Create scanner with content collection configuration\n    this.scanner = options.scanner ?? new ContentScanner(rootDir, options.contentCollection);\n    this._db = options.database ?? new ContentDatabaseHandler(this.dbPath);\n    \n    // Create AI scorer with proper configuration for cost optimization\n    if (options.ai) {\n      this.ai = options.ai;\n    } else {\n      // Create AIScorer with cost-optimized configuration\n      let aiScorerOptions: AIScorerOptions = {};\n      \n      if (options.aiOptions) {\n        aiScorerOptions = options.aiOptions;\n      } else if (options.defaultModelOptions) {\n        // Create a GooseAI instance with the specified model options\n        const gooseAI = new GooseAI(rootDir, options.defaultModelOptions);\n        aiScorerOptions = { ai: gooseAI };\n      }\n      \n      this.ai = new AIScorer(aiScorerOptions);\n    }\n\n    // Ensure database directory exists\n    const dbDir = path.dirname(this.dbPath);\n    fs.mkdir(dbDir, { recursive: true }).catch(console.error);\n  }\n\n  /**\n   * Initialize the system\n   */\n  async initialize(): Promise<void> {\n    await this._db.load();\n  }\n\n  /**\n   * Discover and index content without scoring (lightweight operation)\n   * Creates database entries for new files with 'needs_review' status\n   */\n  async discoverContent(): Promise<string[]> {\n    const files = await this.scanner.scanContent();\n    const database = this._db.getData();\n    const newFiles: string[] = [];\n\n    for (const file of files) {\n      if (!database.entries[file]) {\n        // Create lightweight entry without AI scoring\n        const newEntry: ContentEntry = {\n          path: file,\n          currentScores: {\n            readability: 0,\n            seoScore: 0,\n            technicalAccuracy: 0,\n            engagement: 0,\n            contentDepth: 0\n          },\n          targetScores: DEFAULT_TARGET_SCORES,\n          lastReviewDate: new Date().toISOString(),\n          improvementIterations: 0,\n          status: 'needs_review', // Mark as unreviewed\n          reviewHistory: []\n        };\n\n        await this._db.updateEntry(file, (_entry: ContentEntry | undefined) => newEntry);\n        newFiles.push(file);\n      }\n    }\n\n    // Update database timestamp\n    await this._db.save();\n    \n    return newFiles;\n  }\n\n  /**\n   * Update content index with new files\n   */\n  async updateContentIndex(): Promise<void> {\n    const files = await this.scanner.scanContent();\n    const database = this._db.getData();\n\n    for (const file of files) {\n      if (!database.entries[file]) {\n        // Initialize new content entry\n        const content = await this.scanner.readContent(file);\n        const analysis = await this.ai.scoreContent(content);\n\n        const newEntry: ContentEntry = {\n          path: file,\n          currentScores: analysis.scores,\n          targetScores: DEFAULT_TARGET_SCORES,\n          lastReviewDate: new Date().toISOString(),\n          improvementIterations: 0,\n          status: this.determineStatus(analysis.scores),\n          reviewHistory: [{\n            date: new Date().toISOString(),\n            scores: analysis.scores,\n            improvements: []\n          }]\n        };\n\n        await this._db.updateEntry(file, (_entry: ContentEntry | undefined) => newEntry);\n      }\n    }\n  }\n\n  /**\n   * Get the current database data\n   */\n  getDatabaseData() {\n    return this._db.getData();\n  }\n\n  /**\n   * Get content that needs review (unreviewed/discovered content)\n   * @deprecated Use getContentNeedingReviewDetails() for full content objects\n   */\n  getContentNeedingReview(): string[] {\n    // Ensure database is loaded\n    if (!this._db.getData().lastUpdated) {\n      console.warn('Database not loaded. Call initialize() first.');\n    }\n    const database = this._db.getData();\n    return Object.entries(database.entries || {})\n      .filter(([_, entry]) => entry.status === 'needs_review')\n      .map(([path, _]) => path);\n  }\n\n  /**\n   * Get detailed content objects that need review\n   */\n  getContentNeedingReviewDetails(): ContentEntry[] {\n    // Ensure database is loaded\n    if (!this._db.getData().lastUpdated) {\n      console.warn('Database not loaded. Call initialize() first.');\n    }\n    const database = this._db.getData();\n    return Object.entries(database.entries || {})\n      .filter(([_, entry]) => entry.status === 'needs_review')\n      .map(([_, entry]) => entry);\n  }\n\n  /**\n   * Get content entries by status\n   */\n  getContentByStatus(status: ContentStatus): ContentEntry[] {\n    // Ensure database is loaded\n    if (!this._db.getData().lastUpdated) {\n      console.warn('Database not loaded. Call initialize() first.');\n    }\n    const database = this._db.getData();\n    return Object.entries(database.entries || {})\n      .filter(([_, entry]) => entry.status === status)\n      .map(([_, entry]) => entry);\n  }\n\n  /**\n   * Review/score a specific content file\n   */\n  async reviewContent(path: string): Promise<void> {\n    const database = this._db.getData();\n    const entry = database.entries[path];\n    \n    if (!entry) {\n      throw new Error(`Content not found: ${path}`);\n    }\n\n    if (entry.status !== 'needs_review') {\n      throw new Error(`Content has already been reviewed: ${path}`);\n    }\n\n    // Score the content with AI\n    const content = await this.scanner.readContent(path);\n    const analysis = await this.ai.scoreContent(content);\n\n    // Update entry with scores and proper status\n    const updatedEntry: ContentEntry = {\n      ...entry,\n      currentScores: analysis.scores,\n      lastReviewDate: new Date().toISOString(),\n      status: this.determineStatus(analysis.scores),\n      reviewHistory: [{\n        date: new Date().toISOString(),\n        scores: analysis.scores,\n        improvements: []\n      }]\n    };\n\n    await this._db.updateEntry(path, () => updatedEntry);\n    await this._db.save();\n  }\n\n  /**\n   * Get the entry with the lowest average score (excludes unreviewed content)\n   */\n  getWorstScoringContent(): string | null {\n    const database = this._db.getData();\n    let worstScore = Infinity;\n    let worstPath: string | null = null;\n\n    for (const [path, entry] of Object.entries(database.entries)) {\n      // Skip content that meets targets or hasn't been reviewed yet\n      if (entry.status === 'meets_targets' || entry.status === 'needs_review') continue;\n\n      const avgScore = Object.values(entry.currentScores).reduce((a, b) => a + b, 0) / \n        Object.keys(entry.currentScores).length;\n\n      // Also skip content with zero scores (unreviewed)\n      if (avgScore === 0) continue;\n\n      if (avgScore < worstScore) {\n        worstScore = avgScore;\n        worstPath = path;\n      }\n    }\n\n    return worstPath;\n  }\n\n  /**\n   * Improve content at the specified path\n   */\n  async improveContent(path: string): Promise<void> {\n    const database = this._db.getData();\n    const entry = database.entries[path];\n\n    if (!entry) {\n      throw new Error(`No content found at path: ${path}`);\n    }\n\n    // Read current content\n    const content = await this.scanner.readContent(path);\n    \n    // Get current analysis\n    const analysis = await this.ai.scoreContent(content);\n    \n    // Generate improved content with better error handling\n    let improvedContent: string;\n    try {\n      console.log(`\uD83D\uDCDD Attempting to improve content with ${content.length} characters...`);\n      \n      // Get workflow-specific model options for improvement\n      const improveOptions = await this.getWorkflowModelOptions('improve');\n      \n      if ('improveContentWithCosts' in this.ai && typeof this.ai.improveContentWithCosts === 'function') {\n        const response = await (this.ai as any).improveContentWithCosts(content, analysis, improveOptions);\n        improvedContent = response.content;\n      } else {\n        // Fallback for basic AI implementations\n        improvedContent = await this.ai.improveContent(content, analysis);\n      }\n      \n      console.log(`\u2705 Content improvement successful, got ${improvedContent.length} characters back`);\n      \n      // Validate that we actually got improved content\n      if (!improvedContent || improvedContent.trim().length === 0) {\n        throw new Error('AI returned empty improved content');\n      }\n      \n      if (improvedContent === content) {\n        console.log('\u26A0\uFE0F  Warning: Improved content is identical to original');\n      }\n      \n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error(`\u274C Content improvement failed: ${errorMessage}`);\n      throw error; // Re-throw to prevent silent failures\n    }\n    \n    // Score the improved content\n    const newAnalysis = await this.ai.scoreContent(improvedContent);\n    \n    // Update the content file\n    try {\n      await fs.writeFile(path, improvedContent, 'utf-8');\n      console.log(`\uD83D\uDCC4 Successfully wrote improved content to ${path}`);\n    } catch (writeError) {\n      const errorMessage = writeError instanceof Error ? writeError.message : String(writeError);\n      console.error(`\u274C Failed to write improved content to file: ${errorMessage}`);\n      throw writeError;\n    }\n    \n    // Update database entry\n    await this._db.updateEntry(path, (entry: ContentEntry | undefined) => {\n      if (!entry) {\n        throw new Error(`Entry not found for path: ${path}`);\n      }\n      return {\n        ...entry,\n        currentScores: newAnalysis.scores,\n        lastReviewDate: new Date().toISOString(),\n        improvementIterations: entry.improvementIterations + 1,\n        status: this.determineStatus(newAnalysis.scores),\n        reviewHistory: [\n          ...entry.reviewHistory,\n          {\n            date: new Date().toISOString(),\n            scores: newAnalysis.scores,\n            improvements: Object.values(analysis.analysis).flatMap(a => a.suggestions)\n          }\n        ]\n      };\n    });\n  }\n\n  /**\n   * Determine content status based on scores\n   */\n  private determineStatus(scores: QualityDimensions): ContentEntry['status'] {\n    const avgScore = Object.values(scores).reduce((a, b) => a + b, 0) / \n      Object.keys(scores).length;\n\n    if (avgScore >= 8.5) return 'meets_targets';\n    if (avgScore >= 7.0) return 'needs_improvement';\n    return 'needs_review';\n  }\n\n  /**\n   * Set verbose logging for progress reporting\n   */\n  setVerbose(verbose: boolean): void {\n    this.verbose = verbose;\n    // Update the public config to reflect the change\n    (this.config as any).verbose = verbose;\n  }\n\n  /**\n   * Get current verbose setting\n   */\n  isVerbose(): boolean {\n    return this.verbose;\n  }\n\n  /**\n   * Get current model options being used\n   */\n  getModelOptions(): AIModelOptions | undefined {\n    return this.modelOptions;\n  }\n\n  /**\n   * Log message if verbose mode is enabled\n   * @param message - The message to log\n   * @param level - Log level: 'always' (always log), 'verbose' (only when verbose), 'debug' (extra detail)\n   */\n  private log(message: string, level: 'always' | 'verbose' | 'debug' = 'verbose'): void {\n    if (level === 'always' || (this.verbose && (level === 'verbose' || level === 'debug'))) {\n      // Add timestamp in verbose mode for debugging\n      if (this.verbose && level !== 'always') {\n        const timestamp = new Date().toISOString().substring(11, 23); // HH:mm:ss.SSS\n        console.log(`[${timestamp}] ${message}`);\n      } else {\n        console.log(message);\n      }\n    }\n  }\n\n  // ========== HIGH-LEVEL WORKFLOW METHODS ==========\n\n  /**\n   * Discover content and provide detailed reporting\n   */\n  async discoverAndReport(): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log('\uD83D\uDD0D Starting content discovery...');\n    \n    try {\n      const discovered = await this.discoverContent();\n      const duration = Date.now() - startTime;\n      \n      this.log(`\uD83D\uDCCA Discovery completed: ${discovered.length} files found`);\n      if (discovered.length > 0) {\n        discovered.forEach(file => this.log(`  \uD83D\uDCC4 ${path.basename(file)}`));\n      }\n      \n      return {\n        successful: discovered,\n        failed: [],\n        summary: {\n          total: discovered.length,\n          succeeded: discovered.length,\n          failed: 0,\n          duration\n        }\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.log(`\u274C Discovery failed: ${errorMessage}`);\n      \n      return {\n        successful: [],\n        failed: [{ path: 'discovery', error: errorMessage }],\n        summary: {\n          total: 0,\n          succeeded: 0,\n          failed: 1,\n          duration: Date.now() - startTime\n        }\n      };\n    }\n  }\n\n  /**\n   * Review all content that needs review\n   */\n  async reviewAll(): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log('\uD83D\uDCCA Starting content review...', 'always');\n    \n    // Show configuration details in verbose mode\n    if (this.verbose) {\n      this.log('\uD83D\uDD27 Configuration Details:');\n      this.log(`   Root Directory: ${this.rootDir}`);\n      this.log(`   Database Path: ${this.dbPath}`);\n      this.log(`   Content Collection: ${this.config.contentCollection || 'auto-detected'}`);\n      this.log(`   Model: ${this.config.model || 'default'}`);\n      this.log(`   Provider: ${this.config.provider || 'default'}`);\n      this.log(`   Verbose Mode: ${this.verbose ? '\u2713 enabled' : '\u2717 disabled'}`);\n      this.log('');\n    }\n    \n    await this.initialize();\n    const database = this._db.getData();\n    \n    this.log('\uD83D\uDCCB Database Status:', 'always');\n    this.log(`   Total entries: ${Object.keys(database.entries || {}).length}`, 'always');\n    this.log(`   Last updated: ${database.lastUpdated || 'never'}`, 'always');\n    \n    const allEntries = Object.entries(database.entries || {});\n    const statusCounts = allEntries.reduce((counts, [, entry]) => {\n      counts[entry.status] = (counts[entry.status] || 0) + 1;\n      return counts;\n    }, {} as Record<string, number>);\n    \n    this.log('   Status breakdown:', 'always');\n    Object.entries(statusCounts).forEach(([status, count]) => {\n      this.log(`     ${status}: ${count}`, 'always');\n    });\n    this.log('', 'always');\n    \n    const contentNeedingReview = allEntries\n      .filter(([, entry]) => entry.status === 'needs_review')\n      .map(([path]) => path);\n\n    if (contentNeedingReview.length === 0) {\n      this.log('\u2705 No content needs review', 'always');\n      return {\n        successful: [],\n        failed: [],\n        summary: { total: 0, succeeded: 0, failed: 0, duration: Date.now() - startTime }\n      };\n    }\n\n    this.log(`\uD83D\uDCDD Found ${contentNeedingReview.length} files needing review`, 'always');\n    \n    if (this.verbose) {\n      this.log('\uD83D\uDCC2 Files to review:');\n      contentNeedingReview.forEach((filePath, index) => {\n        this.log(`   ${index + 1}. ${path.basename(filePath)}`);\n      });\n      this.log('');\n    }\n\n    const successful: string[] = [];\n    const failed: { path: string; error: string }[] = [];\n    let totalFileSize = 0;\n    let totalScoreTime = 0;\n\n    for (let i = 0; i < contentNeedingReview.length; i++) {\n      const filePath = contentNeedingReview[i];\n      const fileStartTime = Date.now();\n      \n      try {\n        this.log(`\uD83D\uDCCA Reviewing ${path.basename(filePath)} (${i + 1}/${contentNeedingReview.length})`, 'always');\n        \n        if (this.verbose) {\n          // Show file details\n          try {\n            const fs = await import('fs/promises');\n            const stats = await fs.stat(filePath);\n            const fileSize = Math.round(stats.size / 1024 * 10) / 10; // KB with 1 decimal\n            totalFileSize += stats.size;\n            this.log(`   \uD83D\uDCC4 File size: ${fileSize} KB`, 'debug');\n            this.log(`   \uD83D\uDCC5 Last modified: ${stats.mtime.toISOString()}`, 'debug');\n          } catch (statError) {\n            this.log(`   \u26A0\uFE0F Could not read file stats: ${statError}`, 'debug');\n          }\n        }\n        \n        const reviewStartTime = Date.now();\n        await this.reviewContent(filePath);\n        const reviewDuration = Date.now() - reviewStartTime;\n        totalScoreTime += reviewDuration;\n        \n        // Get updated entry to show scores\n        const updatedDatabase = this._db.getData();\n        const updatedEntry = updatedDatabase.entries[filePath];\n        \n        successful.push(filePath);\n        const fileDuration = Date.now() - fileStartTime;\n        this.log(`\u2705 Reviewed: ${path.basename(filePath)} (${fileDuration}ms)`, 'always');\n        \n        if (this.verbose && updatedEntry) {\n          this.log('   \uD83D\uDCCA Quality Scores:');\n          this.log(`      Readability: ${updatedEntry.currentScores.readability}/10`);\n          this.log(`      SEO Score: ${updatedEntry.currentScores.seoScore}/10`);\n          this.log(`      Technical Accuracy: ${updatedEntry.currentScores.technicalAccuracy}/10`);\n          this.log(`      Engagement: ${updatedEntry.currentScores.engagement}/10`);\n          this.log(`      Content Depth: ${updatedEntry.currentScores.contentDepth}/10`);\n          \n          const avgScore = Object.values(updatedEntry.currentScores).reduce((a, b) => a + b, 0) / 5;\n          this.log(`   \uD83C\uDFAF Average Score: ${Math.round(avgScore * 10) / 10}/10`);\n          this.log(`   \u23F1\uFE0F Review Time: ${reviewDuration}ms`, 'debug');\n        }\n        \n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        failed.push({ path: filePath, error: errorMessage });\n        const fileDuration = Date.now() - fileStartTime;\n        this.log(`\u274C Failed to review ${path.basename(filePath)} (${fileDuration}ms): ${errorMessage}`, 'always');\n        \n        if (this.verbose) {\n          this.log(`   \uD83D\uDD0D Error details: ${error instanceof Error ? error.stack : errorMessage}`, 'debug');\n        }\n      }\n      \n      // Progress indicator\n      const progress = Math.round((i + 1) / contentNeedingReview.length * 100);\n      if (this.verbose) {\n        this.log(`   \uD83D\uDCC8 Progress: ${progress}% (${i + 1}/${contentNeedingReview.length})`, 'debug');\n        this.log('', 'debug');\n      }\n    }\n\n    const duration = Date.now() - startTime;\n    this.log(`\uD83C\uDF89 Review completed: ${successful.length} succeeded, ${failed.length} failed`, 'always');\n    \n    if (this.verbose) {\n      this.log('\uD83D\uDCCA Summary Statistics:');\n      this.log(`   \u23F1\uFE0F Total time: ${duration}ms (${Math.round(duration / 1000 * 10) / 10}s)`);\n      this.log(`   \uD83D\uDCC4 Total file size: ${Math.round(totalFileSize / 1024 * 10) / 10} KB`);\n      this.log(`   \uD83E\uDD16 Total scoring time: ${totalScoreTime}ms`);\n      this.log(`   \u26A1 Average time per file: ${Math.round(duration / contentNeedingReview.length)}ms`);\n      \n      if (successful.length > 0) {\n        this.log(`   \u2705 Success rate: ${Math.round(successful.length / contentNeedingReview.length * 100)}%`);\n      }\n      \n      if (failed.length > 0) {\n        this.log('   \u274C Failed files:');\n        failed.forEach(({path: filePath, error}) => {\n          this.log(`      ${path.basename(filePath)}: ${error}`);\n        });\n      }\n    }\n\n    return {\n      successful,\n      failed,\n      summary: {\n        total: contentNeedingReview.length,\n        succeeded: successful.length,\n        failed: failed.length,\n        duration\n      }\n    };\n  }\n\n  /**\n   * Improve the worst-scoring content\n   */\n  async improveWorst(count: number = 1): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log(`\uD83D\uDE80 Starting improvement of ${count} worst-scoring content...`);\n    \n    await this.initialize();\n    const successful: string[] = [];\n    const failed: { path: string; error: string }[] = [];\n\n    for (let i = 0; i < count; i++) {\n      try {\n        const worstPath = this.getWorstScoringContent();\n        if (!worstPath) {\n          this.log('\u2705 No content needs improvement');\n          break;\n        }\n\n        this.log(`\uD83D\uDCDD Improving ${path.basename(worstPath)} (${i + 1}/${count})`);\n        await this.improveContent(worstPath);\n        successful.push(worstPath);\n        this.log(`\u2705 Improved: ${path.basename(worstPath)}`);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        failed.push({ path: 'improvement', error: errorMessage });\n        this.log(`\u274C Improvement failed: ${errorMessage}`);\n      }\n    }\n\n    const duration = Date.now() - startTime;\n    this.log(`\uD83C\uDF89 Improvement completed: ${successful.length} succeeded, ${failed.length} failed`);\n\n    return {\n      successful,\n      failed,\n      summary: {\n        total: count,\n        succeeded: successful.length,\n        failed: failed.length,\n        duration\n      }\n    };\n  }\n\n  /**\n   * Run the complete workflow: discover -> review -> improve\n   */\n  async runFullWorkflow(options: { improveCount?: number } = {}): Promise<{\n    discovery: WorkflowResult;\n    review: WorkflowResult;\n    improvement: WorkflowResult;\n  }> {\n    this.log('\uD83C\uDFAD Starting complete Shakespeare workflow...');\n\n    const discovery = await this.discoverAndReport();\n    const review = await this.reviewAll();\n    const improvement = await this.improveWorst(options.improveCount || 1);\n\n    this.log('\uD83C\uDF89 Complete workflow finished!');\n\n    return {\n      discovery,\n      review,\n      improvement\n    };\n  }\n\n  /**\n   * Get content health status dashboard\n   */\n  async getStatus(): Promise<{\n    totalFiles: number;\n    needsReview: number;\n    needsImprovement: number;\n    meetsTargets: number;\n    averageScore: number;\n    worstScoring: string | null;\n  }> {\n    await this.initialize();\n    const database = this._db.getData();\n    const entries = Object.entries(database.entries);\n\n    const needsReview = entries.filter(([, entry]) => entry.status === 'needs_review').length;\n    const needsImprovement = entries.filter(([, entry]) => entry.status === 'needs_improvement').length;\n    const meetsTargets = entries.filter(([, entry]) => entry.status === 'meets_targets').length;\n\n    const scores = entries.map(([, entry]) => {\n      const scores = Object.values(entry.currentScores || {});\n      return scores.reduce((a, b) => a + b, 0) / scores.length;\n    }).filter(score => !isNaN(score));\n\n    const averageScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;\n    const worstScoring = this.getWorstScoringContent();\n\n    return {\n      totalFiles: entries.length,\n      needsReview,\n      needsImprovement,\n      meetsTargets,\n      averageScore: Math.round(averageScore * 10) / 10,\n      worstScoring\n    };\n  }\n\n  // ========== STATIC FACTORY METHODS ==========\n\n  /**\n   * Create Shakespeare instance with smart defaults and auto-detection\n   */\n  static async create(config: ShakespeareConfig = {}): Promise<Shakespeare> {\n    const rootDir = config.rootDir || process.cwd();\n    const dbPath = config.dbPath;\n    \n    // Auto-detect project type if not specified\n    const detectedType = await detectProjectType(rootDir);\n    const contentCollection = config.contentCollection || detectedType;\n    \n    // Get optimized model options\n    const defaultModelOptions = getOptimizedModelOptions(config);\n    \n    const options: ShakespeareOptions = {\n      contentCollection,\n      defaultModelOptions\n    };\n    \n    const shakespeare = new Shakespeare(rootDir, dbPath, options);\n    \n    // Store the full configuration that was used to create this instance\n    (shakespeare.config as any) = {\n      ...shakespeare.config,\n      ...config,\n      contentCollection,\n      model: defaultModelOptions?.model || config.model,\n      provider: defaultModelOptions?.provider || config.provider,\n      modelOptions: defaultModelOptions\n    };\n    \n    if (config.verbose) {\n      shakespeare.setVerbose(true);\n    }\n    \n    return shakespeare;\n  }\n\n  /**\n   * Create Shakespeare from configuration file or database config\n   */\n  static async fromConfig(configPath?: string): Promise<Shakespeare> {\n    const { join } = await import('path');\n    const { existsSync, readFileSync } = await import('fs');\n    const rootDir = process.cwd();\n    \n    // Try to find external config file first\n    const possiblePaths = [\n      configPath,\n      join(rootDir, 'shakespeare.config.js'),\n      join(rootDir, 'shakespeare.config.mjs'),\n      join(rootDir, 'shakespeare.config.json'),\n      join(rootDir, '.shakespeare.json')\n    ].filter(Boolean);\n    \n    for (const configFile of possiblePaths) {\n      try {\n        if (existsSync(configFile!)) {\n          let config: ShakespeareConfig;\n          \n          if (configFile!.endsWith('.json')) {\n            config = JSON.parse(readFileSync(configFile!, 'utf-8'));\n          } else {\n            // Dynamic import for JS/MJS files\n            const configModule = await import(configFile!);\n            config = configModule.default || configModule;\n          }\n          \n          const shakespeare = await Shakespeare.create(config);\n          // Ensure verbose setting is applied if specified in config\n          if (config.verbose !== undefined) {\n            shakespeare.setVerbose(config.verbose);\n          }\n          return shakespeare;\n        }\n      } catch (error) {\n        console.warn(`Failed to load config from ${configFile}: ${error}`);\n      }\n    }\n    \n    // Try to load configuration from content database\n    try {\n      const dbPath = join(rootDir, '.shakespeare', 'content-db.json');\n      if (existsSync(dbPath)) {\n        const db = JSON.parse(readFileSync(dbPath, 'utf-8'));\n        if (db.config) {\n          // Convert WorkflowConfig to ShakespeareConfig\n          const shakespeareConfig = await Shakespeare.workflowConfigToShakespeareConfig(db.config, rootDir);\n          const shakespeare = await Shakespeare.create(shakespeareConfig);\n          // Ensure verbose setting from database config is applied\n          if (shakespeareConfig.verbose !== undefined) {\n            shakespeare.setVerbose(shakespeareConfig.verbose);\n          }\n          return shakespeare;\n        }\n      }\n    } catch (error) {\n      console.warn(`Failed to load config from database: ${error}`);\n    }\n    \n    // Fallback to default configuration\n    return await Shakespeare.create();\n  }\n\n  /**\n   * Convert WorkflowConfig to ShakespeareConfig\n   */\n  private static async workflowConfigToShakespeareConfig(workflowConfig: WorkflowConfig, rootDir: string): Promise<ShakespeareConfig> {\n    const config: ShakespeareConfig = {\n      rootDir,\n      verbose: workflowConfig.verbose\n    };\n\n    // Set content collection if specified\n    if (workflowConfig.contentCollection) {\n      config.contentCollection = workflowConfig.contentCollection;\n    }\n\n    // Configure models - use review model as default since it's most commonly used\n    if (workflowConfig.models?.review) {\n      config.model = workflowConfig.models.review;\n    }\n\n    if (workflowConfig.providers?.review) {\n      config.provider = workflowConfig.providers.review;\n    }\n\n    // If both provider and model are specified, combine them\n    if (config.provider || config.model) {\n      config.modelOptions = {\n        provider: config.provider,\n        model: config.model\n      };\n    }\n\n    return config;\n  }\n\n  // ========== WORKFLOW CONFIGURATION METHODS ==========\n\n  /**\n   * Save workflow configuration to the content database\n   */\n  async saveWorkflowConfig(workflowConfig: WorkflowConfig): Promise<void> {\n    await this._db.load();\n    const currentData = this._db.getData();\n    currentData.config = workflowConfig;\n    await this._db.save();\n    this.log('\uD83D\uDCBE Workflow configuration saved to content database');\n  }\n\n  /**\n   * Get current workflow configuration from database\n   */\n  async getWorkflowConfig(): Promise<WorkflowConfig | undefined> {\n    await this._db.load();\n    return this._db.getData().config;\n  }\n\n  /**\n   * Get workflow-specific model options for an operation type\n   */\n  private async getWorkflowModelOptions(workflowType: 'review' | 'improve' | 'generate'): Promise<AIModelOptions | undefined> {\n    const config = await this.getWorkflowConfig();\n    if (!config) return undefined;\n\n    const provider = config.providers?.[workflowType];\n    const model = config.models?.[workflowType];\n\n    if (provider || model) {\n      return { provider, model };\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Factory function for creating Shakespeare instances\n */\nexport function createShakespeare(rootDir?: string, dbPath?: string, options?: ShakespeareOptions): Shakespeare {\n  return new Shakespeare(rootDir, dbPath, options);\n}\n\n/**\n * Auto-detect project type based on file structure\n */\nasync function detectProjectType(rootDir: string): Promise<keyof typeof CONTENT_COLLECTIONS | 'custom'> {\n  try {\n    const { existsSync } = await import('fs');\n    const { join } = await import('path');\n    \n    // Check for Astro\n    if (existsSync(join(rootDir, 'astro.config.mjs')) || \n        existsSync(join(rootDir, 'astro.config.js')) ||\n        existsSync(join(rootDir, 'src/content'))) {\n      return 'astro';\n    }\n    \n    // Check for Next.js\n    if (existsSync(join(rootDir, 'next.config.js')) || \n        existsSync(join(rootDir, 'next.config.mjs'))) {\n      return 'nextjs';\n    }\n    \n    // Check for Gatsby\n    if (existsSync(join(rootDir, 'gatsby-config.js')) || \n        existsSync(join(rootDir, 'gatsby-config.ts'))) {\n      return 'gatsby';\n    }\n    \n    return 'custom';\n  } catch {\n    return 'custom';\n  }\n}\n\n/**\n * Get model options based on optimization preference\n */\nfunction getOptimizedModelOptions(config: ShakespeareConfig): AIModelOptions | undefined {\n  if (config.modelOptions) return config.modelOptions;\n  \n  if (config.model || config.provider) {\n    return {\n      provider: config.provider,\n      model: config.model\n    };\n  }\n  \n  if (config.costOptimized) {\n    return {\n      provider: 'google',\n      model: 'gemini-1.5-flash'\n    };\n  }\n  \n  if (config.qualityFirst) {\n    return {\n      provider: 'anthropic', \n      model: 'claude-3-5-sonnet'\n    };\n  }\n  \n  return undefined;\n}\n\n/**\n * Legacy factory functions (maintained for backward compatibility)\n */\nexport const ShakespeareFactory = {\n  /** Create Shakespeare for Astro projects with content collections */\n  forAstro: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) => \n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'astro' }),\n  \n  /** Create Shakespeare for Next.js projects */\n  forNextJS: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'nextjs' }),\n  \n  /** Create Shakespeare for Gatsby projects */\n  forGatsby: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'gatsby' }),\n  \n  /** Create Shakespeare with custom content collection configuration */\n  forCustom: (contentConfig: ContentCollectionConfig, rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: contentConfig }),\n\n  /** Create cost-optimized Shakespeare with specific model configuration */\n  withCostOptimization: (modelOptions: AIModelOptions, rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, defaultModelOptions: modelOptions })\n};\n", "#!/usr/bin/env node\n\nimport { Shakespeare } from '..';\nimport path from 'path';\n\nasync function main() {\n  const contentDir = process.env.CONTENT_DIR || path.join(process.cwd(), 'content');\n  const dbPath = process.env.DB_PATH || path.join(process.cwd(), '.shakespeare', 'content-db.json');\n\n  const shakespeare = new Shakespeare(contentDir, dbPath);\n  await shakespeare.initialize();\n\n  const worstContentPath = shakespeare.getWorstScoringContent();\n  if (!worstContentPath) {\n    console.log('No content needs improvement');\n    return;\n  }\n\n  console.log(`Improving content: ${worstContentPath}`);\n  await shakespeare.improveContent(worstContentPath);\n  console.log('Content improvement completed');\n}\n\nmain().catch(console.error);\n"],
  "mappings": "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",
  "names": ["fs", "path", "path", "fs", "path", "fs", "entry", "scores", "path"]
}
