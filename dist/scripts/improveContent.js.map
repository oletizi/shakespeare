{
  "version": 3,
  "sources": ["../../src/utils/scanner.ts", "../../src/types/interfaces.ts", "../../src/utils/database.ts", "../../src/utils/constants.ts", "../../src/utils/goose.ts", "../../src/utils/logger.ts", "../../src/utils/uuid.ts", "../../src/utils/chunker.ts", "../../src/utils/content-integrity-validator.ts", "../../src/utils/ai.ts", "../../src/utils/config.ts", "../../src/index.ts", "../../src/scripts/improveContent.ts"],
  "sourcesContent": ["import fs from 'fs/promises';\nimport path from 'path';\nimport { IContentScanner, ContentCollectionConfig, CONTENT_COLLECTIONS } from '@/types/interfaces';\n\n/**\n * Content scanner with configurable content collection support\n */\nexport class ContentScanner implements IContentScanner {\n  private config: ContentCollectionConfig;\n  private rootDir: string;\n\n  constructor(rootDir: string = process.cwd(), config?: ContentCollectionConfig | keyof typeof CONTENT_COLLECTIONS) {\n    this.rootDir = rootDir;\n    \n    // Handle different config types\n    if (typeof config === 'string') {\n      this.config = CONTENT_COLLECTIONS[config] as ContentCollectionConfig;\n    } else if (config) {\n      this.config = config;\n    } else {\n      // Default to Astro content collections\n      this.config = CONTENT_COLLECTIONS.astro as ContentCollectionConfig;\n    }\n  }\n\n  /**\n   * Scan for content files based on configuration\n   */\n  async scanContent(): Promise<string[]> {\n    const contentDir = path.resolve(this.rootDir, this.config.baseDir);\n    \n    // Check if content directory exists\n    try {\n      await fs.access(contentDir);\n    } catch {\n      throw new Error(`Content directory not found: ${contentDir}. Make sure the directory exists or configure a different baseDir.`);\n    }\n\n    const contentFiles: string[] = [];\n    \n    const scan = async (dir: string, relativePath: string = ''): Promise<void> => {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n        const relativeFilePath = path.join(relativePath, entry.name);\n        \n        if (entry.isDirectory()) {\n          await scan(fullPath, relativeFilePath);\n        } else if (entry.isFile()) {\n          // Check if file matches include patterns\n          const shouldInclude = this.matchesPatterns(relativeFilePath, this.config.include);\n          const shouldExclude = this.config.exclude && this.matchesPatterns(relativeFilePath, this.config.exclude);\n          \n          if (shouldInclude && !shouldExclude) {\n            contentFiles.push(fullPath);\n          }\n        }\n      }\n    };\n\n    await scan(contentDir);\n    return contentFiles.sort();\n  }\n\n  /**\n   * Check if a file path matches any of the given glob-like patterns\n   */\n  private matchesPatterns(filePath: string, patterns: readonly string[]): boolean {\n    return patterns.some(pattern => this.matchesPattern(filePath, pattern));\n  }\n\n  /**\n   * Simple glob pattern matching (supports ** and * wildcards)\n   */\n  private matchesPattern(filePath: string, pattern: string): boolean {\n    // Normalize path separators\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\n    const normalizedPattern = pattern.replace(/\\\\/g, '/');\n    \n    // Convert glob pattern to regex\n    let regexPattern = normalizedPattern\n      .replace(/\\./g, '\\\\.')     // Escape dots first\n      .replace(/\\*\\*\\//g, '___DOUBLESTARSLASH___')  // Handle **/ first\n      .replace(/\\*\\*/g, '___DOUBLESTAR___')  // Handle remaining ** \n      .replace(/\\*/g, '[^/]*')   // * matches any filename characters except /\n      .replace(/___DOUBLESTARSLASH___/g, '(?:.*/)?') // **/ matches any path including / (optional for root level)\n      .replace(/___DOUBLESTAR___/g, '(?:.*/)?'); // ** matches any path including / (optional for root level)\n    \n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(normalizedPath);\n  }\n\n  /**\n   * Read content of a markdown file\n   */\n  async readContent(filePath: string): Promise<string> {\n    return fs.readFile(filePath, 'utf-8');\n  }\n}\n", "import { ContentDatabase, ContentEntry } from './content';\nimport { AIContentAnalysis } from '../utils/ai';\n\n/**\n * Content collection configuration for different frameworks\n */\nexport interface ContentCollectionConfig {\n  /** Base directory to scan for content */\n  baseDir: string;\n  /** File patterns to include (glob patterns) */\n  include: readonly string[];\n  /** File patterns to exclude (glob patterns) */\n  exclude?: readonly string[];\n  /** Framework-specific settings */\n  framework?: 'astro' | 'nextjs' | 'gatsby' | 'custom';\n}\n\n/**\n * Predefined content collection configurations\n */\nexport const CONTENT_COLLECTIONS = {\n  astro: {\n    baseDir: 'src/content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/index.md', '**/README.md'],\n    framework: 'astro' as const\n  },\n  nextjs: {\n    baseDir: 'content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/README.md'],\n    framework: 'nextjs' as const\n  },\n  gatsby: {\n    baseDir: 'content',\n    include: ['**/*.mdx', '**/*.md'],\n    exclude: ['**/README.md'],\n    framework: 'gatsby' as const\n  },\n  custom: (baseDir: string, include: string[] = ['**/*.md'], exclude: string[] = []) => ({\n    baseDir,\n    include,\n    exclude,\n    framework: 'custom' as const\n  })\n} as const;\n\n/**\n * AI model configuration options\n */\nexport interface AIModelOptions {\n  /** Provider name (e.g., 'openai', 'anthropic', 'google') */\n  provider?: string;\n  /** Specific model name (e.g., 'gpt-4o-mini', 'claude-3-5-haiku') */\n  model?: string;\n  /** Temperature for response generation */\n  temperature?: number;\n  /** Maximum tokens for response */\n  maxTokens?: number;\n  /** Custom configuration for specific providers */\n  providerConfig?: Record<string, any>;\n}\n\n/**\n * Cost tracking information for AI operations\n */\nexport interface AICostInfo {\n  /** Provider used for the operation */\n  provider: string;\n  /** Model used for the operation */\n  model: string;\n  /** Input tokens consumed */\n  inputTokens: number;\n  /** Output tokens generated */\n  outputTokens: number;\n  /** Total cost in USD */\n  totalCost: number;\n  /** Timestamp of the operation */\n  timestamp: string;\n}\n\n/**\n * Response from AI operations including cost tracking\n */\nexport interface AIResponse {\n  /** The generated text response */\n  content: string;\n  /** Cost and usage information */\n  costInfo: AICostInfo;\n}\n\n/**\n * Interface for AI interaction with multi-model and cost tracking support\n */\nexport interface IAI {\n  /** Original method for backward compatibility */\n  prompt(prompt: string): Promise<string>;\n  /** Enhanced method with model selection and cost tracking */\n  promptWithOptions(prompt: string, options?: AIModelOptions): Promise<AIResponse>;\n  /** Estimate cost before making a request */\n  estimateCost(prompt: string, options?: AIModelOptions): Promise<number>;\n}\n\n/**\n * Interface for file system operations\n */\nexport interface IFileSystem {\n  readFile(path: string, encoding?: BufferEncoding): Promise<string>;\n  writeFile(path: string, data: string, encoding?: BufferEncoding): Promise<void>;\n  readdir(path: string, options?: { withFileTypes?: boolean }): Promise<any[]>;\n  mkdir(path: string, options?: { recursive?: boolean }): Promise<void>;\n}\n\n/**\n * Interface for content scanning\n */\nexport interface IContentScanner {\n  scanContent(): Promise<string[]>;\n  readContent(filePath: string): Promise<string>;\n}\n\n/**\n * Interface for database operations\n */\nexport interface IContentDatabase {\n  load(): Promise<ContentDatabase>;\n  save(): Promise<void>;\n  getData(): ContentDatabase;\n  updateEntry(entryPath: string, updateFn: (entry: ContentEntry | undefined) => ContentEntry): Promise<void>;\n  addOperationCost(entryPath: string, operation: 'review' | 'improve' | 'generate', costInfo: AICostInfo, qualityBefore?: number, qualityAfter?: number): Promise<void>;\n  getCostSummary(specificPath?: string): {\n    totalCosts: { review: number; improvement: number; generation: number; total: number };\n    costsByContent: Record<string, any>;\n    averageCostPerQualityPoint: number;\n    totalOperations: number;\n  };\n}\n\n/**\n * Scoring strategy configuration\n */\nexport interface ScoringStrategy {\n  /** Quality dimension being scored */\n  dimension: 'readability' | 'seoScore' | 'technicalAccuracy' | 'engagement' | 'contentDepth';\n  /** Preferred model for this dimension (optional - uses default if not specified) */\n  preferredModel?: AIModelOptions;\n  /** Cost budget for this scoring operation */\n  maxCostUSD?: number;\n}\n\n/**\n * Enhanced content analysis including cost information\n */\nexport interface EnhancedAIContentAnalysis {\n  /** The analysis results */\n  analysis: AIContentAnalysis;\n  /** Total cost for all scoring operations */\n  totalCost: number;\n  /** Cost breakdown per dimension */\n  costBreakdown: Record<string, AICostInfo>;\n  /** Consolidated cost information for tracking (backward compatibility) */\n  costInfo?: AICostInfo;\n}\n\n/**\n * Interface for AI content scoring with cost optimization\n */\nexport interface IContentScorer {\n  /** Core methods - single implementation path */\n  scoreContent(content: string, strategies?: ScoringStrategy[]): Promise<EnhancedAIContentAnalysis>;\n  improveContent(content: string, analysis: AIContentAnalysis, options?: AIModelOptions): Promise<AIResponse>;\n  \n  /** Array-based model fallback method for content improvement */\n  improveContentWithModels(content: string, analysis: AIContentAnalysis, modelOptions: AIModelOptions[]): Promise<AIResponse>;\n  \n  /** Batch operations for cost optimization */\n  scoreContentBatch(contentList: string[], strategies?: ScoringStrategy[]): Promise<EnhancedAIContentAnalysis[]>;\n  \n  /** Cost estimation for operations */\n  estimateScoringCost(content: string, strategies?: ScoringStrategy[]): Promise<number>;\n  estimateImprovementCost(content: string, analysis: AIContentAnalysis, options?: AIModelOptions): Promise<number>;\n}\n\n/**\n * Shakespeare configuration\n */\nexport interface ShakespeareConfig {\n  /** Use cost-optimized models (cheap, fast) */\n  costOptimized?: boolean;\n  /** Use quality-first models (expensive, best results) */\n  qualityFirst?: boolean;\n  /** Override specific model for all operations */\n  model?: string;\n  /** Override specific provider for all operations */\n  provider?: string;\n  /** Custom model options for all operations */\n  modelOptions?: AIModelOptions;\n  /** Task-specific model configuration - can be single model or array for fallback */\n  models?: {\n    /** Model(s) for content review/scoring operations - tries in order on runtime errors */\n    review?: {\n      model: string;\n      provider?: string;\n    } | string | Array<{\n      model: string;\n      provider?: string;\n    } | string>;\n    /** Model(s) for content improvement operations - tries in order on runtime errors */\n    improve?: {\n      model: string;\n      provider?: string;\n    } | string | Array<{\n      model: string;\n      provider?: string;\n    } | string>;\n    /** Model(s) for content generation operations - tries in order on runtime errors */\n    generate?: {\n      model: string;\n      provider?: string;\n    } | string | Array<{\n      model: string;\n      provider?: string;\n    } | string>;\n  };\n  /** Task-specific model options configuration */\n  taskModelOptions?: {\n    /** Model options for review operations */\n    review?: AIModelOptions;\n    /** Model options for improve operations */\n    improve?: AIModelOptions;\n    /** Model options for generate operations */\n    generate?: AIModelOptions;\n  };\n  /** Enable verbose progress reporting */\n  verbose?: boolean;\n  /** Log level for structured logging */\n  logLevel?: 'error' | 'warn' | 'info' | 'debug';\n  /** Database path override (relative to config file location) */\n  dbPath?: string;\n  /** Content collection override */\n  contentCollection?: ContentCollectionConfig | keyof typeof CONTENT_COLLECTIONS;\n}\n\n/**\n * Content chunk for processing large documents\n */\nexport interface ContentChunk {\n  /** Unique identifier for the chunk */\n  id: string;\n  /** Content of this chunk */\n  content: string;\n  /** Starting line number in original content */\n  startLine: number;\n  /** Ending line number in original content */\n  endLine: number;\n  /** Headers present in this chunk */\n  headers: string[];\n  /** Whether this chunk should preserve frontmatter */\n  preserveFrontmatter: boolean;\n  /** Character count of this chunk */\n  characterCount: number;\n  /** Whether this is the first chunk */\n  isFirst: boolean;\n  /** Whether this is the last chunk */\n  isLast: boolean;\n}\n\n/**\n * Configuration for content chunking\n */\nexport interface ChunkingConfig {\n  /** Maximum characters per chunk */\n  maxChunkSize: number;\n  /** Minimum characters per chunk */\n  minChunkSize: number;\n  /** Whether to split on markdown headers */\n  splitOnHeaders: boolean;\n  /** Header levels to split on (1 = H1, 2 = H2, etc.) */\n  headerLevels: number[];\n  /** Overlap between chunks for context */\n  overlapLines: number;\n}\n\n/**\n * Result of chunk processing\n */\nexport interface ChunkProcessingResult {\n  /** The improved chunk */\n  chunk: ContentChunk;\n  /** Whether the processing succeeded */\n  success: boolean;\n  /** Error message if failed */\n  error?: string;\n  /** Processing metadata */\n  metadata: {\n    originalLength: number;\n    improvedLength: number;\n    lengthRatio: number;\n    processingTime: number;\n  };\n}", "import fs from 'fs/promises';\nimport path from 'path';\nimport { ContentDatabase, ContentEntry, CostAccounting, OperationCostInfo, QualityImprovementMetrics } from '@/types/content';\nimport { IContentDatabase, AICostInfo } from '@/types/interfaces';\n\nexport { ContentDatabase as ContentDatabaseType } from '@/types/content';\n\n/**\n * Database handler for content tracking\n */\nexport class ContentDatabaseHandler implements IContentDatabase {\n  private dbPath: string;\n  private dbDir: string;\n  private data: ContentDatabase = {\n    lastUpdated: new Date().toISOString(),\n    entries: {}\n  };\n\n  constructor(dbPath: string) {\n    this.dbPath = dbPath;\n    this.dbDir = path.dirname(dbPath);\n  }\n\n  /**\n   * Convert absolute path to relative path from database directory\n   */\n  private toRelativePath(absolutePath: string): string {\n    return path.relative(this.dbDir, absolutePath);\n  }\n\n  /**\n   * Convert relative path to absolute path from database directory\n   */\n  private toAbsolutePath(relativePath: string): string {\n    return path.resolve(this.dbDir, relativePath);\n  }\n\n  /**\n   * Load the database from disk\n   */\n  async load(): Promise<ContentDatabase> {\n    try {\n      const content = await fs.readFile(this.dbPath, 'utf-8');\n      this.data = JSON.parse(content);\n      \n      // Convert stored relative paths to absolute paths for internal use\n      const normalizedEntries: { [key: string]: ContentEntry } = {};\n      for (const [relativePath, entry] of Object.entries(this.data.entries)) {\n        const absolutePath = this.toAbsolutePath(relativePath);\n        normalizedEntries[absolutePath] = {\n          ...entry,\n          path: absolutePath // Ensure entry.path is also absolute\n        };\n      }\n      this.data.entries = normalizedEntries;\n      \n      return this.data;\n    } catch (error) {\n      // If file doesn't exist, create new database\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        await this.save();\n        return this.data;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Save the database to disk\n   */\n  async save(): Promise<void> {\n    this.data.lastUpdated = new Date().toISOString();\n    \n    // Ensure database directory exists - fail loudly if we can't create it\n    try {\n      await fs.mkdir(this.dbDir, { recursive: true });\n    } catch (error) {\n      throw new Error(`Failed to create database directory ${this.dbDir}: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    \n    // Convert absolute paths to relative paths for storage\n    const storageData: ContentDatabase = {\n      ...this.data,\n      entries: {}\n    };\n    \n    for (const [absolutePath, entry] of Object.entries(this.data.entries)) {\n      const relativePath = this.toRelativePath(absolutePath);\n      storageData.entries[relativePath] = {\n        ...entry,\n        path: relativePath // Store relative path in entry.path as well\n      };\n    }\n    \n    await fs.writeFile(this.dbPath, JSON.stringify(storageData, null, 2));\n  }\n\n  /**\n   * Get the current database state\n   */\n  getData(): ContentDatabase {\n    return this.data;\n  }\n\n  /**\n   * Update an entry in the database\n   */\n  async updateEntry(entryPath: string, updateFn: (entry: ContentEntry | undefined) => ContentEntry): Promise<void> {\n    this.data.entries[entryPath] = updateFn(this.data.entries[entryPath]);\n    await this.save();\n  }\n\n  /**\n   * Initialize cost accounting for a new content entry\n   */\n  private initializeCostAccounting(): CostAccounting {\n    return {\n      reviewCosts: 0,\n      improvementCosts: 0,\n      generationCosts: 0,\n      totalCost: 0,\n      operationHistory: [],\n      lastUpdated: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Add cost information to a content entry\n   */\n  async addOperationCost(\n    entryPath: string,\n    operation: 'review' | 'improve' | 'generate',\n    costInfo: AICostInfo,\n    qualityBefore?: number,\n    qualityAfter?: number\n  ): Promise<void> {\n    await this.updateEntry(entryPath, (entry) => {\n      if (!entry) {\n        throw new Error(`Content entry not found: ${entryPath}`);\n      }\n\n      // Initialize cost accounting if it doesn't exist (for backward compatibility)\n      if (!entry.costAccounting) {\n        entry.costAccounting = this.initializeCostAccounting();\n      }\n\n      // Create operation cost info\n      const operationCost: OperationCostInfo = {\n        operation,\n        cost: costInfo.totalCost,\n        provider: costInfo.provider,\n        model: costInfo.model,\n        inputTokens: costInfo.inputTokens,\n        outputTokens: costInfo.outputTokens,\n        timestamp: costInfo.timestamp\n      };\n\n      // Add to operation history\n      entry.costAccounting.operationHistory.push(operationCost);\n\n      // Update cumulative costs\n      switch (operation) {\n        case 'review':\n          entry.costAccounting.reviewCosts += costInfo.totalCost;\n          break;\n        case 'improve':\n          entry.costAccounting.improvementCosts += costInfo.totalCost;\n          break;\n        case 'generate':\n          entry.costAccounting.generationCosts += costInfo.totalCost;\n          break;\n      }\n\n      // Update total cost\n      entry.costAccounting.totalCost = \n        entry.costAccounting.reviewCosts + \n        entry.costAccounting.improvementCosts + \n        entry.costAccounting.generationCosts;\n\n      // Update timestamp\n      entry.costAccounting.lastUpdated = new Date().toISOString();\n\n      // Calculate quality improvement metrics if both scores are provided\n      if (operation === 'improve' && qualityBefore !== undefined && qualityAfter !== undefined) {\n        const qualityDelta = qualityAfter - qualityBefore;\n        const improvementMetrics: QualityImprovementMetrics = {\n          scoreBefore: qualityBefore,\n          scoreAfter: qualityAfter,\n          qualityDelta,\n          costPerQualityPoint: qualityDelta > 0 ? costInfo.totalCost / qualityDelta : 0,\n          iterationNumber: entry.improvementIterations\n        };\n\n        // Add to the last review history entry if it exists\n        if (entry.reviewHistory.length > 0) {\n          const lastEntry = entry.reviewHistory[entry.reviewHistory.length - 1];\n          lastEntry.improvementMetrics = improvementMetrics;\n          lastEntry.costInfo = operationCost;\n        }\n      }\n\n      return entry;\n    });\n  }\n\n  /**\n   * Get cost summary for all content or specific content\n   */\n  getCostSummary(specificPath?: string): {\n    totalCosts: { review: number; improvement: number; generation: number; total: number };\n    costsByContent: Record<string, CostAccounting>;\n    averageCostPerQualityPoint: number;\n    totalOperations: number;\n  } {\n    const entries = specificPath \n      ? { [specificPath]: this.data.entries[specificPath] }\n      : this.data.entries;\n\n    let totalReviewCosts = 0;\n    let totalImprovementCosts = 0;\n    let totalGenerationCosts = 0;\n    let totalOperations = 0;\n    let totalQualityPoints = 0;\n    let totalImprovementCost = 0;\n    \n    const costsByContent: Record<string, CostAccounting> = {};\n\n    for (const [path, entry] of Object.entries(entries)) {\n      if (!entry?.costAccounting) continue;\n\n      const costs = entry.costAccounting;\n      costsByContent[path] = costs;\n\n      totalReviewCosts += costs.reviewCosts;\n      totalImprovementCosts += costs.improvementCosts;\n      totalGenerationCosts += costs.generationCosts;\n      totalOperations += costs.operationHistory.length;\n\n      // Calculate quality improvements for ROI analysis\n      for (const historyEntry of entry.reviewHistory) {\n        if (historyEntry.improvementMetrics) {\n          totalQualityPoints += historyEntry.improvementMetrics.qualityDelta;\n          totalImprovementCost += historyEntry.costInfo?.cost || 0;\n        }\n      }\n    }\n\n    const totalCosts = totalReviewCosts + totalImprovementCosts + totalGenerationCosts;\n    const averageCostPerQualityPoint = totalQualityPoints > 0 ? totalImprovementCost / totalQualityPoints : 0;\n\n    return {\n      totalCosts: {\n        review: totalReviewCosts,\n        improvement: totalImprovementCosts,\n        generation: totalGenerationCosts,\n        total: totalCosts\n      },\n      costsByContent,\n      averageCostPerQualityPoint,\n      totalOperations\n    };\n  }\n\n  /**\n   * Ensure entry has cost accounting initialized (for backward compatibility)\n   */\n  async ensureCostAccounting(entryPath: string): Promise<void> {\n    await this.updateEntry(entryPath, (entry) => {\n      if (!entry) {\n        throw new Error(`Content entry not found: ${entryPath}`);\n      }\n\n      if (!entry.costAccounting) {\n        entry.costAccounting = this.initializeCostAccounting();\n      }\n\n      return entry;\n    });\n  }\n}\n", "import { QualityDimensions } from '../types/content';\n\n/**\n * Default target scores for content quality\n */\nexport const DEFAULT_TARGET_SCORES: QualityDimensions = {\n  readability: 8.0,\n  seoScore: 8.5,\n  technicalAccuracy: 9.0,\n  engagement: 8.0,\n  contentDepth: 8.5\n};\n\n/**\n * Configuration for content improvement\n */\nexport const IMPROVEMENT_CONFIG = {\n  maxIterations: 3,\n  minScoreImprovement: 0.5,\n  scoreThreshold: 7.0\n};\n", "import { spawn } from 'child_process';\nimport { IAI, AIModelOptions, AIResponse, AICostInfo } from '@/types/interfaces';\nimport { ShakespeareLogger } from '@/utils/logger';\n\n/**\n * Cost per token (in USD) for different providers/models\n * These are approximate costs and should be updated based on current pricing\n */\nconst MODEL_COSTS = {\n  // OpenAI pricing (per 1M tokens)\n  'openai/gpt-4o-mini': { input: 0.00015, output: 0.0006 },\n  'openai/gpt-4o': { input: 0.005, output: 0.015 },\n  \n  // Anthropic pricing (per 1M tokens)  \n  'anthropic/claude-3-5-haiku': { input: 0.0008, output: 0.004 },\n  'anthropic/claude-3-5-sonnet': { input: 0.003, output: 0.015 },\n  \n  // Google pricing (per 1M tokens)\n  'google/gemini-1.5-flash': { input: 0.000075, output: 0.0003 },\n  'google/gemini-1.5-pro': { input: 0.00125, output: 0.005 },\n  \n  // Groq pricing (per 1M tokens) - very fast inference\n  'groq/llama-3.1-70b': { input: 0.00059, output: 0.00079 },\n  'groq/llama-3.1-8b': { input: 0.00005, output: 0.00008 },\n  \n  // DeepInfra pricing (per 1M tokens) - cost effective\n  'deepinfra/llama-3.1-70b': { input: 0.00052, output: 0.00075 },\n  'deepinfra/deepseek-chat': { input: 0.00014, output: 0.00028 }\n} as const;\n\n/**\n * Default models for cost optimization by task type\n */\nconst DEFAULT_MODELS_BY_TASK = {\n  // Light tasks - use cheapest models\n  scoring: { provider: 'google', model: 'gemini-1.5-flash' },\n  analysis: { provider: 'groq', model: 'llama-3.1-8b' },\n  // Medium tasks - balance cost and quality\n  improvement: { provider: 'anthropic', model: 'claude-3-5-haiku' },\n  // Heavy tasks - use best models\n  generation: { provider: 'anthropic', model: 'claude-3-5-sonnet' }\n} as const;\n\n/**\n * Enhanced Goose AI interaction handler with multi-model support and cost tracking\n */\nexport class GooseAI implements IAI {\n  private gooseCommand: string;\n  private cwd: string;\n  private defaultOptions: AIModelOptions;\n  private logger: ShakespeareLogger;\n\n  constructor(cwd: string = process.cwd(), defaultOptions: AIModelOptions = {}, logger?: ShakespeareLogger) {\n    this.gooseCommand = 'goose'; // Assumes goose is in PATH\n    this.cwd = cwd;\n    this.defaultOptions = defaultOptions;\n    this.logger = logger || new ShakespeareLogger(cwd);\n  }\n\n  /**\n   * Set the logger instance for command logging\n   */\n  setLogger(logger: ShakespeareLogger): void {\n    this.logger = logger;\n  }\n\n  /**\n   * Send a prompt to Goose and get the response using headless mode (backward compatibility)\n   */\n  async prompt(prompt: string): Promise<string> {\n    const response = await this.promptWithOptions(prompt);\n    return response.content;\n  }\n\n  /**\n   * Enhanced prompt method with model selection and cost tracking\n   */\n  async promptWithOptions(prompt: string, options?: AIModelOptions): Promise<AIResponse> {\n    const startTime = Date.now();\n    const finalOptions = { ...this.defaultOptions, ...options };\n    \n    // Build goose command arguments with provider and model selection\n    const args = ['run', '--no-session', '--quiet'];\n    \n    // Only specify provider if explicitly configured\n    if (finalOptions.provider) {\n      args.push('--provider', finalOptions.provider);\n    }\n    \n    // Always specify model if available\n    if (finalOptions.model) {\n      args.push('--model', finalOptions.model);\n    }\n    \n    // Always add --text and prompt at the end\n    args.push('--text', prompt);\n    \n    // Log the command being executed (with content elided)\n    this.logger.logCommand(this.gooseCommand, args, { contentLength: prompt.length });\n\n    return new Promise((resolve, reject) => {\n      const goose = spawn(this.gooseCommand, args, {\n        cwd: this.cwd,\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n\n      let output = '';\n      let error = '';\n\n      goose.stdout.on('data', (data) => {\n        output += data.toString();\n      });\n\n      goose.stderr.on('data', (data) => {\n        error += data.toString();\n      });\n\n      goose.on('close', (code) => {\n        const duration = Date.now() - startTime;\n        \n        if (code !== 0) {\n          // Log failed command timing\n          this.logger.logTiming('Goose command (failed)', duration, { \n            exitCode: code, \n            promptLength: prompt.length,\n            provider: finalOptions.provider,\n            model: finalOptions.model \n          });\n          \n          const errorMsg = `Goose failed with exit code ${code}`;\n          \n          // Enhanced error context for logging (separate from main error message)\n          const errorContext = {\n            exitCode: code,\n            stderr: error || '(empty)',\n            stdout: output || '(empty)',\n            command: this.gooseCommand,\n            args: args,\n            promptLength: prompt.length,\n            modelOptions: finalOptions,\n            duration: duration\n          };\n          \n          // Use centralized error logging - context goes to file only, not console\n          this.logger.logError('Goose AI request', errorMsg, errorContext);\n          \n          reject(new Error(errorMsg));\n        } else {\n          const content = output.trim();\n          const costInfo = this.calculateCostInfo(\n            prompt, \n            content, \n            finalOptions,\n            startTime\n          );\n          \n          // Log successful command timing\n          this.logger.logTiming('Goose command (success)', duration, { \n            promptLength: prompt.length,\n            responseLength: content.length,\n            provider: finalOptions.provider,\n            model: finalOptions.model,\n            estimatedCost: costInfo.totalCost\n          });\n          \n          resolve({\n            content,\n            costInfo\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Estimate cost before making a request\n   */\n  async estimateCost(prompt: string, options?: AIModelOptions): Promise<number> {\n    const finalOptions = { ...this.defaultOptions, ...options };\n    const inputTokens = this.estimateTokens(prompt);\n    const outputTokens = Math.min(inputTokens * 2, 4000); // Estimate output as 2x input, capped\n    \n    return this.calculateCostFromTokens(inputTokens, outputTokens, finalOptions);\n  }\n\n  /**\n   * Calculate cost information for a completed operation\n   */\n  private calculateCostInfo(\n    prompt: string, \n    response: string, \n    options: AIModelOptions,\n    startTime: number\n  ): AICostInfo {\n    const inputTokens = this.estimateTokens(prompt);\n    const outputTokens = this.estimateTokens(response);\n    const totalCost = this.calculateCostFromTokens(inputTokens, outputTokens, options);\n    \n    return {\n      provider: options.provider || 'default',\n      model: options.model || 'default',\n      inputTokens,\n      outputTokens,\n      totalCost,\n      timestamp: new Date(startTime).toISOString()\n    };\n  }\n\n  /**\n   * Calculate cost from token counts and model options\n   */\n  private calculateCostFromTokens(\n    inputTokens: number, \n    outputTokens: number, \n    options: AIModelOptions\n  ): number {\n    const modelKey = `${options.provider || 'openai'}/${options.model || 'gpt-4o-mini'}`;\n    const pricing = MODEL_COSTS[modelKey as keyof typeof MODEL_COSTS];\n    \n    if (!pricing) {\n      // Default to GPT-4o-mini pricing if model not found\n      const defaultPricing = MODEL_COSTS['openai/gpt-4o-mini'];\n      return (inputTokens * defaultPricing.input + outputTokens * defaultPricing.output) / 1000000;\n    }\n    \n    return (inputTokens * pricing.input + outputTokens * pricing.output) / 1000000;\n  }\n\n  /**\n   * Estimate token count for text (rough approximation)\n   */\n  private estimateTokens(text: string): number {\n    // Rough approximation: 4 characters per token on average\n    return Math.ceil(text.length / 4);\n  }\n\n  /**\n   * Get optimal model for a specific task type\n   */\n  getOptimalModelForTask(taskType: keyof typeof DEFAULT_MODELS_BY_TASK): AIModelOptions {\n    return DEFAULT_MODELS_BY_TASK[taskType];\n  }\n}\n", "import winston from 'winston';\nimport { join } from 'path';\nimport { mkdirSync, existsSync, writeFileSync } from 'fs';\n\n/**\n * Maximum character length for console error messages before truncation\n */\nconst MAX_CONSOLE_ERROR_LENGTH = 200;\n\n/**\n * Format error for console display - keeps it concise and user-friendly\n */\nexport function formatErrorForConsole(error: unknown, operation?: string, context?: any): string {\n  let errorMessage: string;\n  \n  if (error instanceof Error) {\n    errorMessage = error.message;\n  } else if (typeof error === 'string') {\n    errorMessage = error;\n  } else {\n    // For objects, JSON, etc., just show the type\n    errorMessage = `Unexpected error type: ${typeof error}`;\n  }\n  \n  // Prefix with operation if provided\n  if (operation) {\n    errorMessage = `${operation}: ${errorMessage}`;\n  }\n  \n  // Add truncated context if provided\n  if (context) {\n    const contextStr = JSON.stringify(context);\n    const maxContextLength = MAX_CONSOLE_ERROR_LENGTH - errorMessage.length - 20; // Leave room for \" (Context: ...)\"\n    \n    if (maxContextLength > 20) { // Only add context if we have reasonable space\n      const truncatedContext = contextStr.length > maxContextLength \n        ? contextStr.substring(0, maxContextLength) + '...'\n        : contextStr;\n      errorMessage += ` (Context: ${truncatedContext})`;\n    }\n  }\n  \n  // Final truncation if still too long\n  if (errorMessage.length > MAX_CONSOLE_ERROR_LENGTH) {\n    errorMessage = errorMessage.substring(0, MAX_CONSOLE_ERROR_LENGTH) + '...';\n  }\n  \n  return errorMessage;\n}\n\n\n/**\n * Structured logger for Shakespeare with configurable verbosity levels\n */\nexport class ShakespeareLogger {\n  private logger: winston.Logger;\n  private verboseEnabled: boolean = false;\n  private errorLogPath: string;\n\n  constructor(rootDir?: string) {\n    // Set up log path in .shakespeare directory\n    const logDir = rootDir ? join(rootDir, '.shakespeare') : join(process.cwd(), '.shakespeare');\n    this.errorLogPath = join(logDir, 'log.txt');\n    \n    // Determine if we can create file logs (skip in test environments with problematic paths)\n    const isTestEnvironment = process.env.NODE_ENV === 'test' || process.env.JEST_WORKER_ID !== undefined;\n    const canCreateLogDir = !isTestEnvironment || rootDir?.startsWith('/tmp') || rootDir?.startsWith(process.cwd());\n    \n    let fileTransport = null;\n    \n    if (canCreateLogDir) {\n      // Ensure .shakespeare directory exists\n      if (!existsSync(logDir)) {\n        try {\n          mkdirSync(logDir, { recursive: true });\n        } catch (error) {\n          // If we can't create the directory, we'll just log to console\n          if (!isTestEnvironment) {\n            console.warn(`Warning: Could not create log directory ${logDir}`);\n          }\n        }\n      }\n\n      // Create .gitignore in .shakespeare directory to ignore log files (if it doesn't exist)\n      if (existsSync(logDir)) {\n        const gitignorePath = join(logDir, '.gitignore');\n        if (!existsSync(gitignorePath)) {\n          try {\n            writeFileSync(gitignorePath, '# Ignore Shakespeare log files\\n*.log*\\n*.txt\\n');\n          } catch (error) {\n            // Non-critical if we can't create .gitignore\n          }\n        }\n      }\n\n      // Try to create file transport\n      if (existsSync(logDir)) {\n        try {\n          fileTransport = new winston.transports.File({\n            filename: this.errorLogPath,\n            level: 'debug', // Log everything to file\n            format: winston.format.combine(\n              winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),\n              winston.format.errors({ stack: true }),\n              winston.format.json()\n            ),\n            maxsize: 10 * 1024 * 1024, // 10MB max file size\n            maxFiles: 5, // Keep 5 log files\n            tailable: true\n          });\n        } catch (error) {\n          // File transport creation failed, continue with console only\n          if (!isTestEnvironment) {\n            console.warn(`Warning: Could not create log file ${this.errorLogPath}`);\n          }\n        }\n      }\n    }\n\n    const transports: winston.transport[] = [\n      // Console transport for regular logging\n      new winston.transports.Console({\n        format: winston.format.combine(\n          winston.format.colorize(),\n          winston.format.printf(({ timestamp, level, message, ...meta }) => {\n            // Truncate meta output for console to prevent verbose logging\n            let metaStr = '';\n            if (Object.keys(meta).length) {\n              const metaJson = JSON.stringify(meta);\n              if (metaJson.length > 100) {\n                metaStr = ` ${metaJson.substring(0, 100)}...}`;\n              } else {\n                metaStr = ` ${metaJson}`;\n              }\n            }\n            const timeStr = typeof timestamp === 'string' ? timestamp.split(' ')[1] : timestamp;\n            return `[${timeStr}] ${level}: ${message}${metaStr}`;\n          })\n        )\n      })\n    ];\n\n    // Add file transport if it was created successfully\n    if (fileTransport) {\n      transports.push(fileTransport);\n    }\n\n    this.logger = winston.createLogger({\n      level: 'info',\n      format: winston.format.combine(\n        winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),\n        winston.format.errors({ stack: true }),\n        winston.format.json()\n      ),\n      transports\n    });\n  }\n\n  /**\n   * Enable or disable verbose logging\n   */\n  setVerbose(enabled: boolean): void {\n    this.verboseEnabled = enabled;\n    this.logger.level = enabled ? 'debug' : 'info';\n  }\n\n  /**\n   * Set explicit log level\n   */\n  setLevel(level: 'error' | 'warn' | 'info' | 'debug'): void {\n    this.logger.level = level;\n    // If debug level is set, enable verbose-style output\n    this.verboseEnabled = level === 'debug';\n  }\n\n  /**\n   * Check if verbose mode is enabled\n   */\n  isVerbose(): boolean {\n    return this.verboseEnabled;\n  }\n\n  /**\n   * Always log - shown regardless of verbose setting\n   */\n  always(message: string, meta?: any): void {\n    this.logger.info(message, meta);\n  }\n\n  /**\n   * Verbose level logging - only shown when verbose is enabled\n   */\n  verbose(message: string, meta?: any): void {\n    if (this.verboseEnabled) {\n      this.logger.info(`\uD83D\uDD27 ${message}`, meta);\n    }\n  }\n\n  /**\n   * Debug level logging - detailed information for debugging\n   */\n  debug(message: string, meta?: any): void {\n    if (this.verboseEnabled) {\n      this.logger.debug(`\uD83D\uDC1B ${message}`, meta);\n    }\n  }\n\n  /**\n   * Info level logging - general information\n   */\n  info(message: string, meta?: any): void {\n    this.logger.info(message, meta);\n  }\n\n  /**\n   * Warning level logging\n   */\n  warn(message: string, meta?: any): void {\n    this.logger.warn(`\u26A0\uFE0F  ${message}`, meta);\n  }\n\n  /**\n   * Error level logging - logs to console and error file\n   */\n  error(message: string, meta?: any): void {\n    this.logger.error(`\u274C ${message}`, meta);\n  }\n\n  /**\n   * Centralized error logging - handles both console (concise) and file (verbose) logging\n   * This should be the single entry point for all error logging in the application\n   */\n  logError(operation: string, error: unknown, context?: any): void {\n    // Always log concise error to console (WITH truncated context)\n    const conciseError = formatErrorForConsole(error, operation, context);\n    console.error(); // Add newline for spacing\n    console.error(`\u274C ${conciseError}`);\n    \n    // Log full error details to file (WITH context)\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorStack = error instanceof Error ? error.stack : undefined;\n    const timestamp = new Date().toISOString();\n    \n    const fullContext = {\n      timestamp,\n      operation: operation || 'Unknown operation',\n      error: errorMessage,\n      stack: errorStack,\n      ...(context && { context }), // Include provided context\n      process: {\n        cwd: process.cwd(),\n        argv: process.argv,\n        version: process.version,\n        platform: process.platform\n      }\n    };\n    \n    this.logger.error('Operation failed', fullContext);\n    \n    // Show file reference if available\n    const hasFileTransport = this.logger.transports.some(t => t instanceof winston.transports.File);\n    if (hasFileTransport && existsSync(this.errorLogPath)) {\n      console.error(`\uD83D\uDCCB Full details logged to: ${this.errorLogPath}`);\n      console.error(`\uD83D\uDCA1 Run: tail -f \"${this.errorLogPath}\" to monitor logs`);\n    }\n    console.error(); // Add newline for spacing\n  }\n\n  /**\n   * Get the path to the error log file\n   */\n  getErrorLogPath(): string {\n    return this.errorLogPath;\n  }\n\n  /**\n   * Log command execution with elided content\n   */\n  logCommand(command: string, args: string[], options?: { contentLength?: number }): void {\n    if (this.verboseEnabled) {\n      // Find and elide text content in arguments\n      const processedArgs = args.map(arg => {\n        // If argument looks like content (long text), elide it\n        if (arg.length > 100 && !arg.startsWith('--') && !arg.includes('/') && !arg.includes('=')) {\n          return `[CONTENT: ${arg.length} chars]`;\n        }\n        return arg;\n      });\n\n      const meta = {\n        command,\n        args: processedArgs,\n        ...(options?.contentLength && { contentLength: options.contentLength })\n      };\n\n      this.logger.debug(`\uD83D\uDE80 Executing command: ${command}`, meta);\n    }\n  }\n\n  /**\n   * Log timing information\n   */\n  logTiming(operation: string, duration: number, meta?: any): void {\n    if (this.verboseEnabled) {\n      this.logger.debug(`\u23F1\uFE0F  ${operation} completed in ${duration}ms`, { duration, ...meta });\n    }\n  }\n\n  /**\n   * Log file processing information\n   */\n  logFileProcessing(filePath: string, operation: string, meta?: any): void {\n    if (this.verboseEnabled) {\n      const fileName = filePath.split('/').pop() || filePath;\n      this.logger.debug(`\uD83D\uDCC4 ${operation}: ${fileName}`, { filePath, operation, ...meta });\n    }\n  }\n\n  /**\n   * Log configuration details\n   */\n  logConfig(config: Record<string, any>): void {\n    if (this.verboseEnabled) {\n      this.logger.info('\uD83D\uDD27 Configuration Details:', config);\n    }\n  }\n\n  /**\n   * Log statistics\n   */\n  logStats(stats: Record<string, any>): void {\n    if (this.verboseEnabled) {\n      this.logger.info('\uD83D\uDCCA Statistics:', stats);\n    }\n  }\n\n  /**\n   * Create a child logger with additional context\n   */\n  child(context: Record<string, any>): winston.Logger {\n    return this.logger.child(context);\n  }\n}", "/**\n * Generate a unique identifier\n */\nexport function generateId(): string {\n  return `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n}", "import { ContentChunk, ChunkingConfig, ChunkProcessingResult } from '@/types/interfaces';\nimport { ShakespeareLogger } from '@/utils/logger';\nimport { generateId } from '@/utils/uuid';\n\n/**\n * Content chunker for processing large documents in manageable pieces\n */\nexport class ContentChunker {\n  private logger: ShakespeareLogger;\n  private config: ChunkingConfig;\n\n  constructor(config?: Partial<ChunkingConfig>, logger?: ShakespeareLogger) {\n    this.logger = logger ?? new ShakespeareLogger();\n    this.config = {\n      maxChunkSize: 8000,   // 8K chars - accounts for 120% expansion in output (8K \u2192 ~9.6K output)\n      minChunkSize: 2000,   // 2K chars minimum\n      splitOnHeaders: true,\n      headerLevels: [1, 2, 3], // H1, H2, H3\n      overlapLines: 2,\n      ...config\n    };\n  }\n\n  /**\n   * Split content into chunks based on headers and size limits\n   */\n  chunkByHeaders(content: string): ContentChunk[] {\n    const lines = content.split('\\n');\n    const chunks: ContentChunk[] = [];\n    let currentChunk: string[] = [];\n    let currentStartLine = 0;\n    let currentHeaders: string[] = [];\n    let frontmatter = this.extractFrontmatter(content);\n\n    // Process each line\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const isHeader = this.isMarkdownHeader(line);\n      const headerLevel = this.getHeaderLevel(line);\n\n      // Check if we should start a new chunk\n      const shouldSplit = this.shouldStartNewChunk(\n        currentChunk,\n        line,\n        isHeader,\n        headerLevel\n      );\n\n      if (shouldSplit && currentChunk.length > 0) {\n        // Create chunk from current content\n        const chunk = this.createChunk(\n          currentChunk,\n          currentStartLine,\n          i - 1,\n          currentHeaders,\n          frontmatter,\n          chunks.length === 0 // isFirst\n        );\n        chunks.push(chunk);\n\n        // Start new chunk with overlap\n        const overlapStart = Math.max(0, i - this.config.overlapLines);\n        currentChunk = lines.slice(overlapStart, i + 1);\n        currentStartLine = overlapStart;\n        currentHeaders = isHeader ? [line.trim()] : [];\n      } else {\n        // Add line to current chunk\n        currentChunk.push(line);\n        if (isHeader) {\n          currentHeaders.push(line.trim());\n        }\n      }\n    }\n\n    // Add the last chunk\n    if (currentChunk.length > 0) {\n      const chunk = this.createChunk(\n        currentChunk,\n        currentStartLine,\n        lines.length - 1,\n        currentHeaders,\n        frontmatter,\n        chunks.length === 0 // isFirst\n      );\n      chunks.push(chunk);\n    }\n\n    // Mark the last chunk\n    if (chunks.length > 0) {\n      chunks[chunks.length - 1].isLast = true;\n    }\n\n    this.logger.info(`Content chunked into ${chunks.length} parts`, {\n      originalLength: content.length,\n      chunkSizes: chunks.map(c => c.characterCount),\n      operation: 'content_chunking'\n    });\n\n    return chunks;\n  }\n\n  /**\n   * Reassemble improved chunks back into complete content\n   */\n  reassembleChunks(improvedChunks: ContentChunk[]): string {\n    if (improvedChunks.length === 0) {\n      return '';\n    }\n\n    if (improvedChunks.length === 1) {\n      return improvedChunks[0].content;\n    }\n\n    let reassembled = '';\n    let frontmatterProcessed = false;\n\n    for (let i = 0; i < improvedChunks.length; i++) {\n      const chunk = improvedChunks[i];\n      let chunkContent = chunk.content;\n\n      // Handle frontmatter - only include it once from the first chunk\n      if (chunk.preserveFrontmatter && !frontmatterProcessed) {\n        frontmatterProcessed = true;\n        // Keep the frontmatter as is\n      } else if (chunk.preserveFrontmatter && frontmatterProcessed) {\n        // Remove frontmatter from subsequent chunks\n        chunkContent = this.removeFrontmatter(chunkContent);\n      }\n\n      // Handle overlap removal between chunks\n      if (i > 0) {\n        chunkContent = this.removeOverlapWithPrevious(\n          chunkContent,\n          improvedChunks[i - 1].content,\n          this.config.overlapLines\n        );\n      }\n\n      reassembled += chunkContent;\n\n      // Add newline between chunks if needed\n      if (i < improvedChunks.length - 1 && !chunkContent.endsWith('\\n')) {\n        reassembled += '\\n';\n      }\n    }\n\n    this.logger.info(`Reassembled ${improvedChunks.length} chunks`, {\n      totalLength: reassembled.length,\n      chunkLengths: improvedChunks.map(c => c.characterCount),\n      operation: 'content_reassembly'\n    });\n\n    return reassembled;\n  }\n\n  /**\n   * Validate that chunks don't have gaps or duplications\n   */\n  validateChunkBoundaries(chunks: ContentChunk[]): boolean {\n    if (chunks.length <= 1) {\n      return true;\n    }\n\n    for (let i = 1; i < chunks.length; i++) {\n      const prevChunk = chunks[i - 1];\n      const currentChunk = chunks[i];\n\n      // Check for reasonable overlap or continuity\n      const gap = currentChunk.startLine - prevChunk.endLine;\n      if (gap > this.config.overlapLines + 1) {\n        this.logger.warn(`Large gap detected between chunks ${i - 1} and ${i}`, {\n          gap,\n          prevEnd: prevChunk.endLine,\n          currentStart: currentChunk.startLine,\n          operation: 'chunk_validation'\n        });\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determine if content should be chunked based on size\n   */\n  shouldChunkContent(content: string): boolean {\n    return content.length > this.config.maxChunkSize;\n  }\n\n  // Private helper methods\n\n  private createChunk(\n    lines: string[],\n    startLine: number,\n    endLine: number,\n    headers: string[],\n    frontmatter: string | null,\n    isFirst: boolean\n  ): ContentChunk {\n    let content = lines.join('\\n');\n    \n    // Add frontmatter to first chunk if it exists\n    if (isFirst && frontmatter) {\n      content = frontmatter + '\\n\\n' + content;\n    }\n\n    return {\n      id: generateId(),\n      content,\n      startLine,\n      endLine,\n      headers,\n      preserveFrontmatter: isFirst && frontmatter !== null,\n      characterCount: content.length,\n      isFirst,\n      isLast: false // Will be set later\n    };\n  }\n\n  private isMarkdownHeader(line: string): boolean {\n    return /^#{1,6}\\s+/.test(line.trim());\n  }\n\n  private getHeaderLevel(line: string): number {\n    const match = line.trim().match(/^(#{1,6})\\s+/);\n    return match ? match[1].length : 0;\n  }\n\n  private shouldStartNewChunk(\n    currentChunk: string[],\n    line: string,\n    isHeader: boolean,\n    headerLevel: number\n  ): boolean {\n    const currentSize = currentChunk.join('\\n').length;\n\n    // Don't split if we haven't reached minimum size\n    if (currentSize < this.config.minChunkSize) {\n      return false;\n    }\n\n    // Split if we're over max size\n    if (currentSize > this.config.maxChunkSize) {\n      return true;\n    }\n\n    // Split on configured header levels\n    if (this.config.splitOnHeaders && isHeader && \n        this.config.headerLevels.includes(headerLevel)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private extractFrontmatter(content: string): string | null {\n    const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n/);\n    return frontmatterMatch ? frontmatterMatch[0] : null;\n  }\n\n  private removeFrontmatter(content: string): string {\n    return content.replace(/^---\\n[\\s\\S]*?\\n---\\n/, '');\n  }\n\n  private removeOverlapWithPrevious(\n    currentContent: string,\n    previousContent: string,\n    overlapLines: number\n  ): string {\n    const currentLines = currentContent.split('\\n');\n    const previousLines = previousContent.split('\\n');\n    \n    // Find common lines at the start of current content\n    let commonLines = 0;\n    const checkLines = Math.min(overlapLines * 2, currentLines.length, previousLines.length);\n    \n    for (let i = 0; i < checkLines; i++) {\n      const currentLine = currentLines[i];\n      const previousLine = previousLines[previousLines.length - checkLines + i];\n      \n      if (currentLine === previousLine) {\n        commonLines++;\n      } else {\n        break;\n      }\n    }\n\n    // Remove the overlapping lines\n    return currentLines.slice(commonLines).join('\\n');\n  }\n}\n\n", "import { ContentIntegrityResult, ContentIntegrityViolation, ContentIntegrityViolationType } from '@/types/content';\nimport { ShakespeareLogger } from '@/utils/logger';\n\n/**\n * Content Integrity Validator\n * \n * This validator enforces strict content integrity rules to prevent AI-generated\n * artifacts, truncation messages, and incomplete content from being saved.\n * \n * INTEGRITY VIOLATIONS ARE BINARY: Content either passes or fails.\n * There is no \"partially acceptable\" content when it comes to integrity.\n */\nexport class ContentIntegrityValidator {\n  private logger: ShakespeareLogger;\n\n  /**\n   * Comprehensive list of patterns that indicate content integrity violations\n   * Each pattern is documented so users understand what's being checked\n   */\n  private static readonly VIOLATION_PATTERNS = {\n    // TRUNCATION MESSAGES - AI ran out of tokens or was interrupted\n    truncation: [\n      {\n        pattern: /\\[Content truncated due to length limit[^\\]]*\\]/gi,\n        description: 'AI model hit output token limit and truncated content'\n      },\n      {\n        pattern: /\\[Content continues\\.\\.\\.\\]/gi,\n        description: 'Content continuation indicator suggesting incomplete output'\n      },\n      {\n        pattern: /\\[Continue with remaining sections[^\\]]*\\]/gi,\n        description: 'Explicit truncation with promise to continue'\n      },\n      {\n        pattern: /\\[Remaining content[^\\]]*\\]/gi,\n        description: 'Reference to missing remaining content'\n      },\n      {\n        pattern: /\\[Additional sections would include[^\\]]*\\]/gi,\n        description: 'Mention of sections that would be included but aren\\'t'\n      },\n      {\n        pattern: /\\[Further sections would cover[^\\]]*\\]/gi,\n        description: 'Reference to further sections that are missing'\n      },\n      {\n        pattern: /\\[The rest of the content[^\\]]*\\]/gi,\n        description: 'Reference to rest of content that isn\\'t present'\n      },\n      {\n        pattern: /\\[Content shortened for brevity[^\\]]*\\]/gi,\n        description: 'AI shortened content instead of providing full version'\n      },\n      {\n        pattern: /\\.\\.\\.?\\s*would continue with[^\\.]{0,100}sections?/gi,\n        description: 'Natural language truncation indicator'\n      }\n    ],\n\n    // AI COMMENTARY - Meta discussion about the content instead of the content itself\n    commentary: [\n      {\n        pattern: /^(Here's|Here is) (the|an?) improved/mi,\n        description: 'AI commentary about improving content'\n      },\n      {\n        pattern: /^I('ve| have) (improved|enhanced|updated)/mi,\n        description: 'First-person AI commentary'\n      },\n      {\n        pattern: /^(Below is|The following is) the improved/mi,\n        description: 'AI introduction to improved content'\n      },\n      {\n        pattern: /^Based on the analysis/mi,\n        description: 'AI explaining its reasoning'\n      },\n      {\n        pattern: /^After reviewing the content/mi,\n        description: 'AI describing its review process'\n      },\n      {\n        pattern: /^(Let me|I'll) (improve|enhance|update)/mi,\n        description: 'AI announcing what it will do'\n      }\n    ],\n\n    // MARKDOWN META ELEMENTS - Special markdown that shouldn't appear in content\n    metaElements: [\n      {\n        pattern: /\\*\\*Note:\\*\\*/gi,\n        description: 'Meta note that shouldn\\'t be in production content'\n      },\n      {\n        pattern: /\\*\\*Disclaimer:\\*\\*/gi,\n        description: 'Meta disclaimer that shouldn\\'t be in production content'\n      },\n      {\n        pattern: /\\*\\*AI Note:\\*\\*/gi,\n        description: 'AI-specific note that shouldn\\'t be in production'\n      }\n    ],\n\n    // PLACEHOLDER CONTENT - Temporary content that needs to be replaced\n    placeholders: [\n      {\n        pattern: /\\[TODO[^\\]]*\\]/gi,\n        description: 'TODO placeholder requiring completion'\n      },\n      {\n        pattern: /\\[PLACEHOLDER[^\\]]*\\]/gi,\n        description: 'Explicit placeholder content'\n      },\n      {\n        pattern: /\\[INSERT[^\\]]*\\]/gi,\n        description: 'Insert instruction placeholder'\n      },\n      {\n        pattern: /\\[ADD[^\\]]*\\]/gi,\n        description: 'Add instruction placeholder'\n      },\n      {\n        pattern: /\\[EXAMPLE[^\\]]*\\]/gi,\n        description: 'Example placeholder needing real content'\n      },\n      {\n        pattern: /\\[Your[^\\]]*here\\]/gi,\n        description: 'User input placeholder'\n      },\n      {\n        pattern: /\\[FIXME[^\\]]*\\]/gi,\n        description: 'Fix-me marker indicating broken content'\n      },\n      {\n        pattern: /XXX/g,\n        description: 'Common programmer placeholder marker'\n      }\n    ]\n  };\n\n  constructor(logger?: ShakespeareLogger) {\n    this.logger = logger ?? new ShakespeareLogger();\n  }\n\n  /**\n   * Validate content integrity\n   * Returns a binary result with detailed violation information\n   */\n  validateContent(content: string, executionId?: string): ContentIntegrityResult {\n    const violations: ContentIntegrityViolation[] = [];\n    const lines = content.split('\\n');\n\n    // Check for truncation violations\n    this.checkViolations(\n      content,\n      lines,\n      ContentIntegrityValidator.VIOLATION_PATTERNS.truncation,\n      ContentIntegrityViolationType.TRUNCATION_MESSAGE,\n      violations\n    );\n\n    // Check for AI commentary violations\n    this.checkViolations(\n      content,\n      lines,\n      ContentIntegrityValidator.VIOLATION_PATTERNS.commentary,\n      ContentIntegrityViolationType.AI_COMMENTARY,\n      violations\n    );\n\n    // Check for meta element violations\n    this.checkViolations(\n      content,\n      lines,\n      ContentIntegrityValidator.VIOLATION_PATTERNS.metaElements,\n      ContentIntegrityViolationType.META_DISCUSSION,\n      violations\n    );\n\n    // Check for placeholder violations\n    this.checkViolations(\n      content,\n      lines,\n      ContentIntegrityValidator.VIOLATION_PATTERNS.placeholders,\n      ContentIntegrityViolationType.TODO_PLACEHOLDER,\n      violations\n    );\n\n    // Check for structural violations\n    this.checkStructuralIntegrity(content, lines, violations);\n\n    const isValid = violations.length === 0;\n\n    // Log result\n    if (executionId) {\n      if (isValid) {\n        this.logger.info(`[${executionId}] Content integrity validation PASSED`, {\n          executionId,\n          contentLength: content.length,\n          operation: 'content_integrity_validation_passed'\n        });\n      } else {\n        this.logger.error(`[${executionId}] Content integrity validation FAILED`, {\n          executionId,\n          violationCount: violations.length,\n          violations: violations.map(v => ({ type: v.type, message: v.message })),\n          operation: 'content_integrity_validation_failed'\n        });\n      }\n    }\n\n    return { isValid, violations };\n  }\n\n  /**\n   * Check for specific violation patterns\n   */\n  private checkViolations(\n    content: string,\n    lines: string[],\n    patterns: Array<{ pattern: RegExp; description: string }>,\n    violationType: ContentIntegrityViolationType,\n    violations: ContentIntegrityViolation[]\n  ): void {\n    for (const { pattern, description } of patterns) {\n      const matches = content.matchAll(pattern);\n      for (const match of matches) {\n        const lineNumber = this.getLineNumber(content, match.index || 0);\n        const snippet = this.getSnippet(lines, lineNumber);\n        \n        violations.push({\n          type: violationType,\n          message: description,\n          lineNumber,\n          snippet\n        });\n      }\n    }\n  }\n\n  /**\n   * Check for structural integrity issues\n   */\n  private checkStructuralIntegrity(\n    content: string,\n    lines: string[],\n    violations: ContentIntegrityViolation[]\n  ): void {\n    // Check for unclosed code blocks\n    const codeBlockCount = (content.match(/```/g) || []).length;\n    if (codeBlockCount % 2 !== 0) {\n      violations.push({\n        type: ContentIntegrityViolationType.UNCLOSED_CODE_BLOCK,\n        message: 'Unclosed code block detected (odd number of ``` markers)'\n      });\n    }\n\n    // Check for malformed frontmatter\n    if (content.startsWith('---')) {\n      const frontmatterEnd = content.indexOf('---', 3);\n      if (frontmatterEnd === -1) {\n        violations.push({\n          type: ContentIntegrityViolationType.MALFORMED_FRONTMATTER,\n          message: 'Frontmatter opened but never closed',\n          lineNumber: 1\n        });\n      } else {\n        // Validate YAML structure (basic check)\n        const frontmatter = content.substring(3, frontmatterEnd);\n        if (frontmatter.includes('---')) {\n          violations.push({\n            type: ContentIntegrityViolationType.MALFORMED_FRONTMATTER,\n            message: 'Multiple --- markers within frontmatter',\n            lineNumber: 1\n          });\n        }\n      }\n    }\n\n    // Check for incomplete sections (headers without content)\n    for (let i = 0; i < lines.length - 1; i++) {\n      const line = lines[i];\n      const nextLine = lines[i + 1];\n      \n      // If we have a header followed immediately by another header or end of file\n      if (/^#{1,6}\\s+/.test(line)) {\n        if (i === lines.length - 1 || /^#{1,6}\\s+/.test(nextLine) || nextLine.trim() === '') {\n          // Check if there's any content in the next few lines\n          let hasContent = false;\n          for (let j = i + 1; j < Math.min(i + 3, lines.length); j++) {\n            if (lines[j].trim() && !/^#{1,6}\\s+/.test(lines[j])) {\n              hasContent = true;\n              break;\n            }\n          }\n          \n          if (!hasContent && line.trim() !== '#' && !line.includes('[WIP]')) {\n            violations.push({\n              type: ContentIntegrityViolationType.INCOMPLETE_SECTION,\n              message: `Header \"${line.trim()}\" has no content`,\n              lineNumber: i + 1,\n              snippet: line\n            });\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get line number from character index\n   */\n  private getLineNumber(content: string, charIndex: number): number {\n    return content.substring(0, charIndex).split('\\n').length;\n  }\n\n  /**\n   * Get snippet of content around a line\n   */\n  private getSnippet(lines: string[], lineNumber: number, context: number = 1): string {\n    const startLine = Math.max(0, lineNumber - 1 - context);\n    const endLine = Math.min(lines.length, lineNumber + context);\n    \n    return lines\n      .slice(startLine, endLine)\n      .map((line, index) => {\n        const currentLineNum = startLine + index + 1;\n        const marker = currentLineNum === lineNumber ? '>>> ' : '    ';\n        return `${marker}${currentLineNum}: ${line}`;\n      })\n      .join('\\n');\n  }\n\n  /**\n   * Get a human-readable report of violations\n   */\n  static formatViolationReport(result: ContentIntegrityResult): string {\n    if (result.isValid) {\n      return '\u2705 Content integrity check PASSED - No violations found';\n    }\n\n    const report: string[] = [\n      '\u274C Content integrity check FAILED',\n      `Found ${result.violations.length} violation(s):\\n`\n    ];\n\n    // Group violations by type\n    const violationsByType = new Map<ContentIntegrityViolationType, ContentIntegrityViolation[]>();\n    for (const violation of result.violations) {\n      if (!violationsByType.has(violation.type)) {\n        violationsByType.set(violation.type, []);\n      }\n      violationsByType.get(violation.type)!.push(violation);\n    }\n\n    // Format each type\n    for (const [type, violations] of violationsByType) {\n      report.push(`\\n${this.getViolationTypeHeader(type)}:`);\n      for (const violation of violations) {\n        report.push(`  \u2022 ${violation.message}`);\n        if (violation.lineNumber) {\n          report.push(`    Line ${violation.lineNumber}`);\n        }\n        if (violation.snippet) {\n          report.push(`    ${violation.snippet.split('\\n').join('\\n    ')}`);\n        }\n      }\n    }\n\n    return report.join('\\n');\n  }\n\n  /**\n   * Get human-readable violation type header\n   */\n  private static getViolationTypeHeader(type: ContentIntegrityViolationType): string {\n    const headers: Record<ContentIntegrityViolationType, string> = {\n      [ContentIntegrityViolationType.TRUNCATION_MESSAGE]: '\uD83D\uDEAB Truncation Issues',\n      [ContentIntegrityViolationType.AI_COMMENTARY]: '\uD83E\uDD16 AI Commentary',\n      [ContentIntegrityViolationType.META_DISCUSSION]: '\uD83D\uDCDD Meta Discussion',\n      [ContentIntegrityViolationType.UNCLOSED_CODE_BLOCK]: '\uD83D\uDCBB Code Block Issues',\n      [ContentIntegrityViolationType.INCOMPLETE_SECTION]: '\uD83D\uDCC4 Incomplete Sections',\n      [ContentIntegrityViolationType.TODO_PLACEHOLDER]: '\u26A0\uFE0F TODO Placeholders',\n      [ContentIntegrityViolationType.EXAMPLE_PLACEHOLDER]: '\uD83D\uDCCB Example Placeholders',\n      [ContentIntegrityViolationType.INSERT_PLACEHOLDER]: '\u2795 Insert Placeholders',\n      [ContentIntegrityViolationType.BROKEN_MARKDOWN]: '\uD83D\uDD27 Broken Markdown',\n      [ContentIntegrityViolationType.MALFORMED_FRONTMATTER]: '\u2699\uFE0F Malformed Frontmatter'\n    };\n    \n    return headers[type] || type;\n  }\n}", "import { GooseAI } from '@/utils/goose';\nimport { QualityDimensions } from '@/types/content';\nimport { IAI, IContentScorer, ScoringStrategy, EnhancedAIContentAnalysis, AIModelOptions, AIResponse, AICostInfo, ContentChunk } from '@/types/interfaces';\nimport { ShakespeareLogger } from '@/utils/logger';\nimport { ContentChunker } from '@/utils/chunker';\nimport { ContentIntegrityValidator } from '@/utils/content-integrity-validator';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport interface AIScoreResponse {\n  score: number;\n  reasoning: string;\n  suggestions?: string[];\n}\n\nexport interface AIContentAnalysis {\n  scores: QualityDimensions;\n  analysis: {\n    [K in keyof QualityDimensions]: {\n      reasoning: string;\n      suggestions: string[];\n    }\n  };\n}\n\n/**\n * Prompts for content analysis\n */\nexport const ANALYSIS_PROMPTS = {\n  readability: `\n    Analyze the following content for readability. Consider sentence structure, vocabulary level, paragraph organization, transitions, and clarity.\n    \n    You MUST respond in this exact format:\n    \n    SCORE: [number from 0-10]\n    REASONING: [2-3 sentences explaining the score]\n    SUGGESTIONS:\n    - [Specific actionable suggestion 1]\n    - [Specific actionable suggestion 2]\n    - [Specific actionable suggestion 3]\n    \n    Score meanings:\n    0-3: Difficult to read, needs major revision\n    4-6: Somewhat readable but needs improvement  \n    7-8: Good readability with minor issues\n    9-10: Excellent, clear and engaging\n    \n    Content to analyze:\n    {content}\n    `,\n\n  seoScore: `\n    Evaluate the following content for SEO effectiveness. Consider keyword usage, header structure, content length, and search intent alignment.\n    \n    You MUST respond in this exact format:\n    \n    SCORE: [number from 0-10]\n    REASONING: [2-3 sentences explaining the score]\n    SUGGESTIONS:\n    - [Specific actionable suggestion 1]\n    - [Specific actionable suggestion 2]\n    - [Specific actionable suggestion 3]\n    \n    Score meanings:\n    0-3: Poor SEO optimization, needs major improvements\n    4-6: Basic SEO with significant room for improvement\n    7-8: Good SEO optimization with minor gaps\n    9-10: Excellent SEO optimization\n    \n    Content to analyze:\n    {content}\n    `,\n\n  technicalAccuracy: `\n    Review the following content for technical accuracy. Consider factual correctness, code examples, terminology usage, and up-to-date information.\n    \n    You MUST respond in this exact format:\n    \n    SCORE: [number from 0-10]\n    REASONING: [2-3 sentences explaining the score]\n    SUGGESTIONS:\n    - [Specific actionable suggestion 1]\n    - [Specific actionable suggestion 2]\n    - [Specific actionable suggestion 3]\n    \n    Score meanings:\n    0-3: Contains significant technical errors\n    4-6: Some technical inaccuracies need fixing\n    7-8: Generally accurate with minor issues\n    9-10: Highly accurate and well-researched\n    \n    Content to analyze:\n    {content}\n    `,\n\n  engagement: `\n    Evaluate the content's engagement level. Consider writing style, examples, reader interaction elements, and storytelling.\n    \n    You MUST respond in this exact format:\n    \n    SCORE: [number from 0-10]\n    REASONING: [2-3 sentences explaining the score]\n    SUGGESTIONS:\n    - [Specific actionable suggestion 1]\n    - [Specific actionable suggestion 2]\n    - [Specific actionable suggestion 3]\n    \n    Score meanings:\n    0-3: Dry and unengaging, needs major improvements\n    4-6: Somewhat engaging but significant room for improvement\n    7-8: Good engagement level with minor enhancements needed\n    9-10: Highly engaging and compelling\n    \n    Content to analyze:\n    {content}\n    `,\n\n  contentDepth: `\n    Analyze the content's depth and comprehensiveness. Consider topic coverage, supporting evidence, explanation thoroughness, and advanced concepts.\n    \n    You MUST respond in this exact format:\n    \n    SCORE: [number from 0-10]\n    REASONING: [2-3 sentences explaining the score]\n    SUGGESTIONS:\n    - [Specific actionable suggestion 1]\n    - [Specific actionable suggestion 2]\n    - [Specific actionable suggestion 3]\n    \n    Score meanings:\n    0-3: Surface level only, needs significant depth\n    4-6: Basic coverage with some depth, needs expansion\n    7-8: Good depth with most aspects covered\n    9-10: Comprehensive and thorough coverage\n    \n    Content to analyze:\n    {content}\n    `\n};\n\n/**\n * Prompt for content improvement\n */\nexport const IMPROVEMENT_PROMPT = `\nTASK: Improve the provided content based on the quality analysis while maintaining its full length and comprehensive coverage.\n\nANALYSIS AND CONTENT:\n{analysis}\n\nORIGINAL CONTENT TO IMPROVE:\n{content}\n\nMANDATORY OUTPUT REQUIREMENTS - VIOLATION WILL RESULT IN REJECTION:\n\n1. LENGTH REQUIREMENT: Your output must be 80-120% the length of the original content\n   - Original length: Approximately {contentLength} characters  \n   - Required output: 80-120% of original length\n   - DO NOT TRUNCATE, SUMMARIZE, OR CONDENSE\n   - INCLUDE ALL SECTIONS, EXAMPLES, AND DETAILS\n\n2. COMPLETE CONTENT REQUIREMENT: \n   - Provide the ENTIRE improved content, not partial content\n   - DO NOT use \"[Continue with remaining sections...]\" or similar\n   - Every section, code block, and example must be included in full\n   - If you cannot complete the full content, do not attempt the task\n\n3. NO COMMENTARY: \n   - Start immediately with the frontmatter or first content line\n   - NO preamble like \"I'll analyze...\" or \"Here's the improved...\"  \n   - NO explanatory text before or after the content\n   - ONLY provide the complete improved content\n\n4. STRUCTURE PRESERVATION:\n   - Preserve ALL frontmatter EXACTLY (YAML between --- delimiters)\n   - Maintain all code blocks, examples, and technical details\n   - Keep the same document structure and format\n   - Preserve all MDX/JSX components\n\nIMPROVEMENT GUIDELINES:\nFocus on the lowest-scoring dimensions from the analysis:\n- Enhance readability without removing content depth\n- Improve technical accuracy of code examples and explanations  \n- Increase engagement through better examples and clearer language\n- Optimize for SEO with better headers and keyword usage\n- Expand content depth where analysis suggests gaps\n\nCRITICAL: This is not a content creation task. You are improving existing comprehensive content. Every section, example, and detail from the original must be present in your improved version, enhanced but not removed.\n\nBegin your response immediately with the content (frontmatter first if present):\n`;\n\n/**\n * Parse Goose response to extract score, reasoning, and suggestions\n * Handles the structured format: SCORE: X, REASONING: Y, SUGGESTIONS: - item1, - item2\n */\nfunction parseGooseResponse(response: string): AIScoreResponse {\n  let score = 7.0; // Default score\n  let reasoning = 'Analysis completed';\n  const suggestions: string[] = [];\n  \n  try {\n    const lines = response.split('\\n').map(l => l.trim()).filter(Boolean);\n    let inSuggestions = false;\n    \n    for (const line of lines) {\n      // Look for structured format first\n      if (line.startsWith('SCORE:')) {\n        const scoreMatch = line.match(/SCORE:\\s*(\\d+(?:\\.\\d+)?)/);\n        if (scoreMatch) {\n          score = parseFloat(scoreMatch[1]);\n        }\n      } else if (line.startsWith('REASONING:')) {\n        reasoning = line.replace(/^REASONING:\\s*/, '').trim();\n      } else if (line === 'SUGGESTIONS:') {\n        inSuggestions = true;\n      } else if (inSuggestions && line.startsWith('- ')) {\n        suggestions.push(line.slice(2).trim());\n      } else if (inSuggestions && !line.startsWith('- ') && line.length > 0) {\n        // Stop collecting suggestions if we hit non-bullet text\n        inSuggestions = false;\n      }\n      \n      // Fallback: if no structured format, try old parsing\n      if (!line.startsWith('SCORE:') && !line.startsWith('REASONING:') && !line.startsWith('SUGGESTIONS:')) {\n        // Look for standalone number (old format)\n        if (line.match(/^\\d+(\\.\\d+)?$/)) {\n          score = parseFloat(line);\n        } else if (line.startsWith('- ') && suggestions.length === 0) {\n          // Only collect old-format suggestions if we haven't found structured ones\n          suggestions.push(line.slice(2).trim());\n        } else if (reasoning === 'Analysis completed' && line.length > 20) {\n          // Use longer lines as reasoning if we haven't found structured reasoning\n          reasoning = line;\n        }\n      }\n    }\n    \n    // Ensure we have at least some suggestions even if parsing partially failed\n    if (suggestions.length === 0) {\n      suggestions.push('Review content structure and clarity');\n      suggestions.push('Consider adding more specific examples');\n      suggestions.push('Enhance explanation depth where needed');\n    }\n    \n  } catch (error) {\n    console.warn('Error parsing AI response, using defaults:', error);\n  }\n  \n  return {\n    score,\n    reasoning,\n    suggestions\n  };\n}\n\n/**\n * Options for AIScorer constructor\n */\nexport interface AIScorerOptions {\n  ai?: IAI;\n  logger?: ShakespeareLogger;\n  defaultModelOptions?: AIModelOptions;\n}\n\n/**\n * AI scoring system implementation with cost optimization\n */\nexport class AIScorer implements IContentScorer {\n  private ai: IAI;\n  private logger: ShakespeareLogger;\n  private defaultModelOptions?: AIModelOptions;\n  private chunker: ContentChunker;\n  private integrityValidator: ContentIntegrityValidator;\n\n  constructor(options: AIScorerOptions = {}) {\n    this.ai = options.ai ?? new GooseAI();\n    this.logger = options.logger ?? new ShakespeareLogger();\n    this.defaultModelOptions = options.defaultModelOptions;\n    this.chunker = new ContentChunker({}, this.logger);\n    this.integrityValidator = new ContentIntegrityValidator(this.logger);\n  }\n\n  /**\n   * Score content across all quality dimensions\n   */\n  /**\n   * Score content across all quality dimensions\n   * This is the single entry point for content scoring\n   */\n  async scoreContent(content: string, strategies?: ScoringStrategy[]): Promise<EnhancedAIContentAnalysis> {\n    const analysis: Partial<AIContentAnalysis> = {\n      scores: {} as QualityDimensions,\n      analysis: {} as AIContentAnalysis['analysis']\n    };\n    \n    const costBreakdown: Record<string, AICostInfo> = {};\n    let totalCost = 0;\n\n    // Use default strategies if none provided - respect configured model options\n    const defaultModel = this.defaultModelOptions || { provider: 'google', model: 'gemini-1.5-flash' };\n    \n    const scoringStrategies: ScoringStrategy[] = strategies || [\n      { dimension: 'readability', preferredModel: defaultModel },\n      { dimension: 'seoScore', preferredModel: defaultModel },\n      { dimension: 'technicalAccuracy', preferredModel: defaultModel },\n      { dimension: 'engagement', preferredModel: defaultModel },\n      { dimension: 'contentDepth', preferredModel: defaultModel }\n    ];\n\n    // Score each dimension with cost tracking\n    for (const strategy of scoringStrategies) {\n      const promptTemplate = ANALYSIS_PROMPTS[strategy.dimension];\n      const prompt = promptTemplate.replace('{content}', content);\n      \n      try {\n        const result = await this.scoreDimensionWithCost(prompt, strategy.preferredModel);\n        \n        // Update scores and analysis\n        (analysis.scores as any)[strategy.dimension] = result.response.score;\n        (analysis.analysis as any)[strategy.dimension] = {\n          reasoning: result.response.reasoning,\n          suggestions: result.response.suggestions || []\n        };\n        \n        // Track costs\n        costBreakdown[strategy.dimension] = result.costInfo;\n        totalCost += result.costInfo.totalCost;\n        \n      } catch (error) {\n        this.logger.logError(`Error scoring ${strategy.dimension}`, error);\n        // Fail loudly - don't hide errors with default values\n        throw new Error(`Failed to score ${strategy.dimension}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n\n    return {\n      analysis: analysis as AIContentAnalysis,\n      totalCost,\n      costBreakdown\n    };\n  }\n\n  /**\n   * Score content for a specific dimension\n   */\n  private async scoreDimension(content: string, prompt: string): Promise<AIScoreResponse> {\n    try {\n      const response = await this.ai.prompt(prompt);\n      return parseGooseResponse(response);\n    } catch (error) {\n      this.logger.logError('Error scoring content', error);\n      // Fail loudly - don't hide errors with default values\n      throw new Error(`Content scoring failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Generate improved content based on analysis\n   * This is the single entry point for content improvement\n   */\n  async improveContent(content: string, analysis: AIContentAnalysis, options?: AIModelOptions): Promise<AIResponse> {\n    if (options) {\n      return this.improveContentWithModels(content, analysis, [options]);\n    } else {\n      // Pass undefined to let the AI use its defaultOptions\n      return this.improveContentWithModels(content, analysis, [undefined as any]);\n    }\n  }\n\n  async improveContentWithModels(content: string, analysis: AIContentAnalysis, modelOptions: AIModelOptions[], filePath?: string): Promise<AIResponse> {\n    if (!modelOptions || modelOptions.length === 0) {\n      throw new Error('At least one model option must be provided');\n    }\n    \n    // Check if content should be chunked\n    if (this.chunker.shouldChunkContent(content)) {\n      return this.improveContentWithChunking(content, analysis, modelOptions, undefined, filePath);\n    }\n    \n    // Use single-pass improvement for smaller content\n    return this.improveSingleContent(content, analysis, modelOptions);\n  }\n\n  /**\n   * Resume an interrupted chunk improvement\n   */\n  async resumeChunkedImprovement(executionId: string): Promise<AIResponse> {\n    this.logger.info(`Resuming chunked improvement ${executionId}`);\n    \n    // Load progress data\n    const progress = await this.loadChunkProgress(executionId);\n    \n    if (!progress.originalContent || !progress.analysis) {\n      throw new Error(`Cannot resume ${executionId}: missing original content or analysis data`);\n    }\n    \n    const modelOptions = progress.modelOptions || this.getDefaultModelOptions('improve');\n    \n    // Continue with stored data\n    return this.improveContentWithChunking(\n      progress.originalContent, \n      progress.analysis, \n      modelOptions, \n      executionId\n    );\n  }\n\n  /**\n   * Get default model options for a task\n   */\n  private getDefaultModelOptions(task: 'improve' | 'review' = 'improve'): AIModelOptions[] {\n    // Default fallback chain\n    if (task === 'improve') {\n      return [\n        { provider: 'anthropic', model: 'claude-3-5-sonnet' },\n        { provider: 'openai', model: 'gpt-4o' }\n      ];\n    } else {\n      return [\n        { provider: 'openai', model: 'gpt-4o-mini' },\n        { provider: 'anthropic', model: 'claude-3-5-haiku' }\n      ];\n    }\n  }\n\n  /**\n   * Improve large content using chunking approach\n   */\n  private async improveContentWithChunking(content: string, analysis: AIContentAnalysis, modelOptions: AIModelOptions[], providedExecutionId?: string, filePath?: string): Promise<AIResponse> {\n    const executionId = providedExecutionId || `improve-chunked-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const timestamp = new Date().toISOString();\n    \n    this.logger.info(`[${executionId}] Starting chunked content improvement at ${timestamp}`, {\n      executionId,\n      originalContentLength: content.length,\n      timestamp,\n      operation: 'improve_content_chunked_start'\n    });\n    \n    // Split content into chunks\n    const chunks = this.chunker.chunkByHeaders(content);\n    \n    this.logger.info(`[${executionId}] Content split into ${chunks.length} chunks`, {\n      executionId,\n      chunkCount: chunks.length,\n      chunkSizes: chunks.map(c => c.characterCount),\n      operation: 'improve_content_chunks_created'\n    });\n    \n    // Initialize chunk progress tracking\n    const chunkProgress = await this.loadChunkProgress(executionId);\n    \n    // Store original content and analysis for resume functionality (only if not resuming)\n    if (!providedExecutionId) {\n      await this.saveChunkProgress(executionId, {\n        originalContent: content,\n        analysis: analysis,\n        chunks: chunks.map(c => ({ ...c, content: c.content })), // Store original chunks\n        improvedChunks: [],\n        totalCost: 0,\n        lastProcessedIndex: -1,\n        totalChunks: chunks.length,\n        modelOptions: modelOptions,\n        startTime: new Date().toISOString(),\n        filePath: filePath\n      });\n    }\n    \n    // Improve each chunk\n    const improvedChunks: ContentChunk[] = chunkProgress.improvedChunks || [];\n    let totalCost = chunkProgress.totalCost || 0;\n    \n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      \n      // Check if chunk was already processed\n      if (i < improvedChunks.length) {\n        this.logger.info(`[${executionId}] Skipping already processed chunk ${i + 1}/${chunks.length}`, {\n          executionId,\n          chunkIndex: i,\n          chunkId: chunk.id,\n          operation: 'improve_content_chunk_skipped'\n        });\n        continue;\n      }\n      \n      this.logger.info(`[${executionId}] Processing chunk ${i + 1}/${chunks.length}`, {\n        executionId,\n        chunkIndex: i,\n        chunkId: chunk.id,\n        chunkSize: chunk.characterCount,\n        operation: 'improve_content_chunk_start'\n      });\n      \n      try {\n        // Improve this chunk\n        const chunkResponse = await this.improveSingleContent(chunk.content, analysis, modelOptions, `${executionId}-chunk-${i}`);\n        \n        // Create improved chunk\n        const improvedChunk: ContentChunk = {\n          ...chunk,\n          content: chunkResponse.content\n        };\n        \n        improvedChunks.push(improvedChunk);\n        totalCost += chunkResponse.costInfo.totalCost;\n        \n        // Save progress after each successful chunk\n        await this.saveChunkProgress(executionId, {\n          improvedChunks,\n          totalCost,\n          lastProcessedIndex: i,\n          totalChunks: chunks.length\n        });\n        \n        this.logger.info(`[${executionId}] Chunk ${i + 1} improved successfully`, {\n          executionId,\n          chunkIndex: i,\n          originalLength: chunk.characterCount,\n          improvedLength: chunkResponse.content.length,\n          lengthRatio: chunkResponse.content.length / chunk.characterCount,\n          operation: 'improve_content_chunk_completed'\n        });\n        \n      } catch (error) {\n        this.logger.error(`[${executionId}] Failed to improve chunk ${i + 1}`, {\n          executionId,\n          chunkIndex: i,\n          error: error instanceof Error ? error.message : String(error),\n          operation: 'improve_content_chunk_failed'\n        });\n        throw new Error(`Failed to improve chunk ${i + 1}/${chunks.length}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n    \n    // Reassemble chunks\n    const reassembledContent = this.chunker.reassembleChunks(improvedChunks);\n    \n    this.logger.info(`[${executionId}] Chunked content improvement completed`, {\n      executionId,\n      originalLength: content.length,\n      finalLength: reassembledContent.length,\n      lengthRatio: reassembledContent.length / content.length,\n      chunkCount: chunks.length,\n      totalCost,\n      operation: 'improve_content_chunked_completed'\n    });\n    \n    // Validate content integrity (binary pass/fail)\n    const integrityResult = this.integrityValidator.validateContent(reassembledContent, executionId);\n    if (!integrityResult.isValid) {\n      const report = ContentIntegrityValidator.formatViolationReport(integrityResult);\n      this.logger.error(`[${executionId}] Content integrity validation failed`, {\n        executionId,\n        violations: integrityResult.violations,\n        operation: 'improve_content_integrity_failed'\n      });\n      throw new Error(`Content integrity validation failed:\\n${report}`);\n    }\n    \n    // Validate length (warning only, not a hard failure)\n    this.validateContentLength(reassembledContent, content, executionId);\n    \n    return {\n      content: reassembledContent,\n      costInfo: {\n        provider: modelOptions[0]?.provider || 'unknown',\n        model: modelOptions[0]?.model || 'unknown',\n        inputTokens: Math.round(content.length / 4), // Rough estimate\n        outputTokens: Math.round(reassembledContent.length / 4),\n        totalCost,\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n\n  /**\n   * Improve content without chunking (original method renamed)\n   */\n  private async improveSingleContent(content: string, analysis: AIContentAnalysis, modelOptions: AIModelOptions[], executionId?: string): Promise<AIResponse> {\n    // Generate unique execution ID for tracking\n    const finalExecutionId = executionId || `improve-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const timestamp = new Date().toISOString();\n    \n    // Write detailed execution logs to file only\n    this.logger.info(`[${finalExecutionId}] Starting content improvement at ${timestamp}`, {\n      executionId: finalExecutionId,\n      originalContentLength: content.length,\n      timestamp,\n      operation: 'improve_content_start'\n    });\n    \n    const analysisStr = JSON.stringify(analysis, null, 2);\n    const prompt = IMPROVEMENT_PROMPT\n      .replace('{analysis}', analysisStr)\n      .replace('{content}', content)\n      .replace('{contentLength}', content.length.toString());\n    \n    this.logger.info(`[${finalExecutionId}] Full improvement request`, {\n      executionId: finalExecutionId,\n      promptLength: prompt.length,\n      fullPrompt: prompt,\n      originalContent: content,\n      operation: 'improve_content_full_request',\n      originalContentLength: content.length\n    });\n\n    // Always use promptWithOptions - no fallbacks\n    if (!('promptWithOptions' in this.ai) || typeof this.ai.promptWithOptions !== 'function') {\n      throw new Error('AI implementation must support promptWithOptions method');\n    }\n\n    // Try each model in order until one succeeds\n    let lastError: Error | undefined;\n    for (let i = 0; i < modelOptions.length; i++) {\n      const currentModel = modelOptions[i];\n      const isFirstModel = i === 0;\n      const hasMoreModels = i < modelOptions.length - 1;\n      \n      try {\n        this.logger.info(`[${finalExecutionId}] Sending AI request${isFirstModel ? '' : ` (fallback ${i})`}`, {\n          executionId,\n          options: currentModel,\n          modelIndex: i,\n          totalModels: modelOptions.length,\n          operation: isFirstModel ? 'improve_content_ai_request' : 'improve_content_fallback_request'\n        });\n        \n        const response = await (this.ai as any).promptWithOptions(prompt, currentModel);\n        \n        this.logger.info(`[${finalExecutionId}] Received AI response${isFirstModel ? '' : ` (fallback succeeded)`}`, {\n          executionId,\n          responseLength: response.content.length,\n          fullResponse: response.content,\n          modelIndex: i,\n          operation: isFirstModel ? 'improve_content_ai_response' : 'improve_content_fallback_success'\n        });\n        \n        if (!isFirstModel) {\n          console.warn(`\u2705 Fallback successful! Used ${currentModel.provider}/${currentModel.model}\\n`);\n        }\n        \n        // Success! Process and return the response\n        return this.processAIResponse(response, finalExecutionId, content);\n        \n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        \n        // Check if this is a runtime error that should trigger fallback\n        const errorMessage = lastError.message;\n        const isRuntimeError = errorMessage.startsWith('USAGE_CAP:') || \n                              errorMessage.startsWith('RUNTIME_ERROR:') ||\n                              errorMessage.includes('Interrupted before the model replied') ||\n                              errorMessage.includes('connection') ||\n                              errorMessage.includes('timeout') ||\n                              errorMessage.includes('rate limit') ||\n                              errorMessage.includes('server error') ||\n                              errorMessage.includes('service unavailable');\n        \n        this.logger.error(`[${finalExecutionId}] Model ${i + 1}/${modelOptions.length} failed`, {\n          executionId,\n          modelIndex: i,\n          model: currentModel,\n          error: errorMessage.substring(0, 200),\n          isRuntimeError,\n          operation: isFirstModel ? 'improve_content_primary_failed' : 'improve_content_fallback_failed'\n        });\n        \n        if (hasMoreModels && isRuntimeError) {\n          // Show user-friendly fallback message\n          const errorType = errorMessage.startsWith('USAGE_CAP:') ? 'Usage Limit' : 'Runtime Error';\n          const friendlyMessage = errorMessage.startsWith('USAGE_CAP:') ? \n            errorMessage.replace('USAGE_CAP: ', '') : \n            errorMessage.replace('RUNTIME_ERROR: ', '');\n          \n          if (isFirstModel) {\n            console.warn(`\\n\u26A0\uFE0F  Primary AI model failed: ${errorType}`);\n            console.warn(`   ${friendlyMessage}`);\n          } else {\n            console.warn(`\u26A0\uFE0F  Fallback ${i} failed: ${errorType}`);\n          }\n          console.warn(`   Attempting fallback to ${modelOptions[i + 1].provider}/${modelOptions[i + 1].model}...\\n`);\n          \n          // Continue to next model\n          continue;\n        } else if (!isRuntimeError || !hasMoreModels) {\n          // Either not a runtime error (don't fallback) or no more models to try\n          break;\n        }\n      }\n    }\n    \n    // All models failed\n    throw new Error(`All ${modelOptions.length} model(s) failed. Last error: ${lastError?.message || 'Unknown error'}`);\n  }\n\n  /**\n   * Validate content length (warnings only, not a hard failure)\n   */\n  private validateContentLength(improvedContent: string, originalContent: string, executionId: string): void {\n    const originalLength = originalContent.length;\n    const finalLength = improvedContent.length;\n    const lengthRatio = finalLength / originalLength;\n\n    if (finalLength < originalLength * 0.7) {\n      // This is suspicious enough to still throw an error\n      this.logger.error(`[${executionId}] Content too short - likely parsing error or excessive condensation`, {\n        executionId,\n        originalLength,\n        finalLength,\n        lengthRatio,\n        operation: 'improve_content_validation_error'\n      });\n      throw new Error(`AI returned suspiciously short content (${finalLength} chars vs original ${originalLength} chars). Content should be 70-120% of original length.`);\n    } else if (finalLength < originalLength * 0.85) {\n      this.logger.warn(`[${executionId}] Content shorter than expected but acceptable`, {\n        executionId,\n        originalLength,\n        finalLength,\n        lengthRatio,\n        operation: 'improve_content_validation_warning'\n      });\n      console.warn(`\u26A0\uFE0F  Improved content is shorter than expected (${Math.round(lengthRatio * 100)}% of original). This may indicate over-condensation.`);\n    } else if (finalLength > originalLength * 1.2) {\n      this.logger.warn(`[${executionId}] Content longer than expected`, {\n        executionId,\n        originalLength,\n        finalLength,\n        lengthRatio,\n        operation: 'improve_content_validation_info'\n      });\n      console.log(`\u2139\uFE0F  Improved content is longer than original (${Math.round(lengthRatio * 100)}% of original). This may indicate good expansion of ideas.`);\n    }\n  }\n\n  private processAIResponse(response: AIResponse, executionId: string, originalContent: string): AIResponse {\n    \n    // Log the full response content for debugging\n    this.logger.debug(`[${executionId}] Full AI response content`, {\n      executionId,\n      fullResponse: response.content,\n      responseLength: response.content.length,\n      operation: 'improve_content_full_response'\n    });\n    \n    // The AI should return the complete improved content\n    // We expect the entire response to be the improved content based on our prompt\n    let improvedContent = response.content.trim();\n    \n    this.logger.debug(`[${executionId}] Processing AI response`, {\n      executionId,\n      trimmedLength: improvedContent.length,\n      operation: 'improve_content_processing'\n    });\n    \n    // Basic validation\n    if (!improvedContent || improvedContent.length === 0) {\n      this.logger.error(`[${executionId}] AI returned empty content`, {\n        executionId,\n        operation: 'improve_content_empty_error'\n      });\n      throw new Error('AI returned empty improved content');\n    }\n    \n    // Check for goose error responses and classify them\n    const hasGooseError = /Interrupted before the model replied/i.test(improvedContent) ||\n                          /error: The error above was an exception we were not able to handle/i.test(improvedContent);\n    \n    if (hasGooseError) {\n      // Extract the actual error details from the response\n      const errorResponse = improvedContent;\n      \n      // Classify the error type based on actual goose error patterns\n      const isUsageCapError = /usage limits|quota|limit exceeded|rate limit/i.test(errorResponse) ||\n                             /You have reached your specified API usage limits/i.test(errorResponse) ||\n                             /regain access on \\d{4}-\\d{2}-\\d{2}/i.test(errorResponse) ||\n                             /invalid_request_error.*usage/i.test(errorResponse);\n      \n      const isAuthError = /authentication|unauthorized|invalid.*key|api.*key.*invalid/i.test(errorResponse) &&\n                         !isUsageCapError; // Usage cap errors often mention auth but aren't auth issues\n      \n      const isServerError = /500|502|503|504|timeout|server.*error|internal.*error/i.test(errorResponse) ||\n                           /network.*error|connection.*error/i.test(errorResponse) ||\n                           /Failed to parse response/i.test(errorResponse);\n      \n      const isRuntimeError = isUsageCapError || isServerError;\n      \n      this.logger.error(`[${executionId}] Goose returned error instead of AI response`, {\n        executionId,\n        errorResponse: errorResponse.substring(0, 1000),\n        errorType: isUsageCapError ? 'usage_cap' : isAuthError ? 'authentication' : isServerError ? 'server_error' : 'unknown',\n        isRuntimeError,\n        operation: 'improve_content_goose_error'\n      });\n      \n      if (isUsageCapError) {\n        // Extract usage cap details for better user messaging\n        const usageLimitMatch = errorResponse.match(/You have reached your specified API usage limits\\. You will regain access on (\\d{4}-\\d{2}-\\d{2})/);\n        if (usageLimitMatch) {\n          throw new Error(`USAGE_CAP: API usage limit reached. Access will be restored on ${usageLimitMatch[1]}`);\n        } else {\n          throw new Error(`USAGE_CAP: ${errorResponse.split('\\n')[0]}`);\n        }\n      } else if (isRuntimeError) {\n        throw new Error(`RUNTIME_ERROR: ${errorResponse.split('\\n')[0]}`);\n      } else {\n        throw new Error(`AI provider failed: ${errorResponse.split('\\n')[0]}`);\n      }\n    }\n    \n    // Check if the AI included unwanted preamble (common patterns)\n    const unwantedPreambles = [\n      /^I'll help.*?\\n\\n/i,\n      /^Here's the improved.*?\\n\\n/i,\n      /^Let me.*?\\n\\n/i,\n      /^I've improved.*?\\n\\n/i,\n      /^Below is.*?\\n\\n/i,\n      /^The improved.*?\\n\\n/i\n    ];\n    \n    let preambleRemoved = false;\n    for (const pattern of unwantedPreambles) {\n      if (pattern.test(improvedContent)) {\n        const beforeLength = improvedContent.length;\n        // Remove the preamble and everything before the actual content\n        improvedContent = improvedContent.replace(pattern, '');\n        const afterLength = improvedContent.length;\n        \n        this.logger.info(`[${executionId}] Removed preamble`, {\n          executionId,\n          patternMatched: pattern.toString(),\n          charsRemoved: beforeLength - afterLength,\n          operation: 'improve_content_preamble_removed'\n        });\n        preambleRemoved = true;\n        break;\n      }\n    }\n    \n    if (!preambleRemoved) {\n      this.logger.debug(`[${executionId}] No preamble detected`, {\n        executionId,\n        operation: 'improve_content_no_preamble'\n      });\n    }\n    \n    // Ensure frontmatter is preserved (if original had it)\n    const originalHasFrontmatter = originalContent.trim().startsWith('---');\n    const improvedHasFrontmatter = improvedContent.trim().startsWith('---');\n    \n    if (originalHasFrontmatter && !improvedHasFrontmatter) {\n      // Extract original frontmatter\n      const frontmatterEndIndex = originalContent.indexOf('---', 3);\n      if (frontmatterEndIndex !== -1) {\n        const originalFrontmatter = originalContent.substring(0, frontmatterEndIndex + 3);\n        // Prepend original frontmatter if AI didn't preserve it\n        improvedContent = originalFrontmatter + '\\n\\n' + improvedContent;\n        \n        this.logger.info(`[${executionId}] Restored missing frontmatter`, {\n          executionId,\n          frontmatterLength: originalFrontmatter.length,\n          operation: 'improve_content_frontmatter_restored'\n        });\n      }\n    }\n    \n    // Final validation and detailed logging\n    const finalLength = improvedContent.length;\n    const originalLength = originalContent.length;\n    const lengthRatio = finalLength / originalLength;\n    \n    this.logger.info(`[${executionId}] Content improvement completed`, {\n      executionId,\n      originalLength,\n      finalLength,\n      lengthRatio,\n      finalContent: improvedContent,\n      operation: 'improve_content_completed'\n    });\n    \n    // Validate content integrity (binary pass/fail gate)\n    const integrityResult = this.integrityValidator.validateContent(improvedContent, executionId);\n    if (!integrityResult.isValid) {\n      const report = ContentIntegrityValidator.formatViolationReport(integrityResult);\n      this.logger.error(`[${executionId}] Content integrity validation failed`, {\n        executionId,\n        violations: integrityResult.violations,\n        operation: 'improve_content_integrity_failed'\n      });\n      throw new Error(`Content integrity validation failed:\\n${report}`);\n    }\n    \n    // Validate length (warning only, not a hard failure)\n    if (finalLength < originalLength * 0.7) {\n      this.logger.error(`[${executionId}] Content too short - likely parsing error or excessive condensation`, {\n        executionId,\n        originalLength,\n        finalLength,\n        lengthRatio,\n        operation: 'improve_content_validation_error'\n      });\n      throw new Error(`AI returned suspiciously short content (${finalLength} chars vs original ${originalLength} chars). Content should be 70-120% of original length.`);\n    } else if (finalLength < originalLength * 0.85) {\n      this.logger.warn(`[${executionId}] Content shorter than expected but acceptable`, {\n        executionId,\n        originalLength,\n        finalLength,\n        lengthRatio,\n        operation: 'improve_content_validation_warning'\n      });\n      console.warn(`\u26A0\uFE0F  Improved content is shorter than expected (${Math.round(lengthRatio * 100)}% of original). This may indicate over-condensation.`);\n    } else if (finalLength > originalLength * 1.2) {\n      this.logger.warn(`[${executionId}] Content longer than expected`, {\n        executionId,\n        originalLength,\n        finalLength,\n        lengthRatio,\n        operation: 'improve_content_validation_info'\n      });\n      console.log(`\u2139\uFE0F  Improved content is longer than original (${Math.round(lengthRatio * 100)}% of original). This may indicate good expansion of ideas.`);\n    }\n    \n    return {\n      content: improvedContent,\n      costInfo: response.costInfo\n    };\n  }\n\n  // Remove scoreContentWithCosts - use scoreContent directly\n\n  // Remove improveContentWithCosts - use improveContent directly\n\n  /**\n   * Batch scoring for cost optimization\n   */\n  async scoreContentBatch(contentList: string[], strategies?: ScoringStrategy[]): Promise<EnhancedAIContentAnalysis[]> {\n    // For now, process sequentially. In the future, this could be enhanced with actual batch API calls\n    const results: EnhancedAIContentAnalysis[] = [];\n    \n    for (const content of contentList) {\n      const result = await this.scoreContent(content, strategies);\n      results.push(result);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Estimate cost for scoring operation\n   */\n  async estimateScoringCost(content: string, strategies?: ScoringStrategy[]): Promise<number> {\n    if (!('estimateCost' in this.ai) || typeof this.ai.estimateCost !== 'function') {\n      return 0; // Cannot estimate without enhanced AI\n    }\n\n    const defaultModel = this.defaultModelOptions || { provider: 'google', model: 'gemini-1.5-flash' };\n    \n    const defaultStrategies: ScoringStrategy[] = strategies || [\n      { dimension: 'readability', preferredModel: defaultModel },\n      { dimension: 'seoScore', preferredModel: defaultModel },\n      { dimension: 'technicalAccuracy', preferredModel: defaultModel },\n      { dimension: 'engagement', preferredModel: defaultModel },\n      { dimension: 'contentDepth', preferredModel: defaultModel }\n    ];\n\n    let totalEstimatedCost = 0;\n    \n    for (const strategy of defaultStrategies) {\n      const promptTemplate = ANALYSIS_PROMPTS[strategy.dimension];\n      const prompt = promptTemplate.replace('{content}', content);\n      const cost = await (this.ai as any).estimateCost(prompt, strategy.preferredModel);\n      totalEstimatedCost += cost;\n    }\n    \n    return totalEstimatedCost;\n  }\n\n  /**\n   * Estimate cost for improvement operation\n   */\n  async estimateImprovementCost(content: string, analysis: AIContentAnalysis, options?: AIModelOptions): Promise<number> {\n    if (!('estimateCost' in this.ai) || typeof this.ai.estimateCost !== 'function') {\n      return 0; // Cannot estimate without enhanced AI\n    }\n\n    const analysisStr = JSON.stringify(analysis, null, 2);\n    const prompt = IMPROVEMENT_PROMPT\n      .replace('{analysis}', analysisStr)\n      .replace('{content}', content)\n      .replace('{contentLength}', content.length.toString());\n\n    // Use provided options or let GooseAI use its configured defaults  \n    return await (this.ai as any).estimateCost(prompt, options);\n  }\n\n  /**\n   * Load chunk progress from disk\n   */\n  private async loadChunkProgress(executionId: string): Promise<any> {\n    const progressPath = path.join(this.getProgressDir(), `${executionId}.json`);\n    try {\n      const content = await fs.readFile(progressPath, 'utf-8');\n      return JSON.parse(content);\n    } catch {\n      // No existing progress\n      return {\n        improvedChunks: [],\n        totalCost: 0,\n        lastProcessedIndex: -1\n      };\n    }\n  }\n\n  /**\n   * Save chunk progress to disk\n   */\n  private async saveChunkProgress(executionId: string, progress: any): Promise<void> {\n    const progressDir = this.getProgressDir();\n    const progressPath = path.join(progressDir, `${executionId}.json`);\n    \n    try {\n      // Ensure directory exists\n      await fs.mkdir(progressDir, { recursive: true });\n      \n      // Save progress\n      await fs.writeFile(progressPath, JSON.stringify(progress, null, 2));\n      \n      this.logger.info(`Saved chunk progress for ${executionId}`, {\n        executionId,\n        lastProcessedIndex: progress.lastProcessedIndex,\n        totalChunks: progress.totalChunks,\n        totalCost: progress.totalCost\n      });\n    } catch (error) {\n      this.logger.error(`Failed to save chunk progress`, {\n        executionId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Get progress directory path\n   */\n  private getProgressDir(): string {\n    // Store in .shakespeare/progress directory\n    const baseDir = process.cwd();\n    return path.join(baseDir, '.shakespeare', 'progress');\n  }\n\n  /**\n   * Clean up old progress files\n   */\n  private async cleanupOldProgress(daysToKeep: number = 7): Promise<void> {\n    const progressDir = this.getProgressDir();\n    try {\n      const files = await fs.readdir(progressDir);\n      const cutoffTime = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);\n      \n      for (const file of files) {\n        const filePath = path.join(progressDir, file);\n        const stats = await fs.stat(filePath);\n        \n        if (stats.mtimeMs < cutoffTime) {\n          await fs.unlink(filePath);\n          this.logger.info(`Cleaned up old progress file: ${file}`);\n        }\n      }\n    } catch (error) {\n      // Directory might not exist yet\n      if ((error as any).code !== 'ENOENT') {\n        this.logger.error(`Failed to cleanup old progress files`, {\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    }\n  }\n\n  /**\n   * Score a specific dimension with cost tracking\n   */\n  private async scoreDimensionWithCost(prompt: string, modelOptions?: AIModelOptions): Promise<{\n    response: AIScoreResponse;\n    costInfo: AICostInfo;\n  }> {\n    if ('promptWithOptions' in this.ai && typeof this.ai.promptWithOptions === 'function') {\n      const response = await (this.ai as any).promptWithOptions(prompt, modelOptions);\n      return {\n        response: parseGooseResponse(response.content),\n        costInfo: response.costInfo\n      };\n    } else {\n      // Fallback for basic IAI implementations\n      const responseText = await this.ai.prompt(prompt);\n      return {\n        response: parseGooseResponse(responseText),\n        costInfo: {\n          provider: modelOptions?.provider || 'unknown',\n          model: modelOptions?.model || 'unknown',\n          inputTokens: Math.ceil(prompt.length / 4),\n          outputTokens: Math.ceil(responseText.length / 4),\n          totalCost: 0,\n          timestamp: new Date().toISOString()\n        }\n      };\n    }\n  }\n}\n\n/**\n * Factory function for creating AIScorer instances\n */\nexport function createAIScorer(options?: AIScorerOptions): AIScorer {\n  return new AIScorer(options);\n}\n", "import { readFileSync, existsSync } from 'fs';\nimport { resolve, dirname, join } from 'path';\nimport { ShakespeareConfig } from '@/types/interfaces';\n\n/**\n * Configuration loading and validation utilities\n */\n\nexport class InvalidConfigError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InvalidConfigError';\n  }\n}\n\n/**\n * Find configuration file in current directory or project root\n */\nexport function findConfigFile(startDir: string = process.cwd()): string | null {\n  const configNames = ['.shakespeare.json', 'shakespeare.json'];\n  let currentDir = resolve(startDir);\n\n  while (true) {\n    for (const configName of configNames) {\n      const configPath = join(currentDir, configName);\n      if (existsSync(configPath)) {\n        return configPath;\n      }\n    }\n\n    const parentDir = dirname(currentDir);\n    if (parentDir === currentDir) {\n      break; // Reached root directory\n    }\n    currentDir = parentDir;\n  }\n\n  return null;\n}\n\n/**\n * Load and validate Shakespeare configuration from file\n */\nexport function loadConfig(configPath?: string): ShakespeareConfig | null {\n  const actualConfigPath = configPath || findConfigFile();\n  if (!actualConfigPath) {\n    return null;\n  }\n\n  try {\n    const configData = readFileSync(actualConfigPath, 'utf8');\n    const config = JSON.parse(configData) as ShakespeareConfig;\n    \n    validateConfig(config);\n    return config;\n  } catch (error: any) {\n    if (error instanceof InvalidConfigError) {\n      throw error;\n    }\n    throw new InvalidConfigError(`Failed to load configuration from ${actualConfigPath}: ${error.message}`);\n  }\n}\n\n/**\n * Validate Shakespeare configuration format\n */\nfunction validateConfig(config: any): void {\n  if (!config || typeof config !== 'object') {\n    throw new InvalidConfigError('Configuration must be a valid JSON object');\n  }\n\n  // Validate model configuration structure if present\n  if (config.models) {\n    for (const [workflowType, modelConfig] of Object.entries(config.models)) {\n      if (!['review', 'improve', 'generate'].includes(workflowType)) {\n        throw new InvalidConfigError(`Invalid workflow type in models: ${workflowType}`);\n      }\n      \n      if (typeof modelConfig === 'string') {\n        // String format is valid\n        continue;\n      } else if (typeof modelConfig === 'object' && modelConfig !== null) {\n        const obj = modelConfig as any;\n        if (!obj.model || typeof obj.model !== 'string') {\n          throw new InvalidConfigError(`Model configuration for ${workflowType} must have a 'model' property with string value`);\n        }\n        if (obj.provider && typeof obj.provider !== 'string') {\n          throw new InvalidConfigError(`Provider in ${workflowType} model configuration must be a string`);\n        }\n      } else {\n        throw new InvalidConfigError(`Model configuration for ${workflowType} must be either a string or object with model/provider properties`);\n      }\n    }\n  }\n\n  // Validate taskModelOptions if present\n  if (config.taskModelOptions) {\n    for (const [workflowType, options] of Object.entries(config.taskModelOptions)) {\n      if (!['review', 'improve', 'generate'].includes(workflowType)) {\n        throw new InvalidConfigError(`Invalid workflow type in taskModelOptions: ${workflowType}`);\n      }\n      \n      if (typeof options !== 'object' || options === null) {\n        throw new InvalidConfigError(`Task model options for ${workflowType} must be an object`);\n      }\n    }\n  }\n}", "import { ContentScanner } from '@/utils/scanner';\nimport { ContentDatabaseHandler } from '@/utils/database';\nimport { DEFAULT_TARGET_SCORES } from '@/utils/constants';\nimport { ContentEntry, QualityDimensions, ContentStatus } from '@/types/content';\nimport { AIScorer, AIContentAnalysis, AIScorerOptions } from '@/utils/ai';\nimport { GooseAI } from '@/utils/goose';\nimport { ShakespeareLogger } from '@/utils/logger';\nimport { IContentScanner, IContentDatabase, IContentScorer, ContentCollectionConfig, CONTENT_COLLECTIONS, AIModelOptions, ShakespeareConfig } from '@/types/interfaces';\nimport { loadConfig, InvalidConfigError } from '@/utils/config';\nimport path from 'path';\nimport fs from 'fs/promises';\n\nexport * from '@/types/content';\nexport * from '@/types/interfaces';\nexport { GooseAI } from '@/utils/goose';\nexport { AIScorer } from '@/utils/ai';\nexport * from '@/utils/schema-validation';\n\n/**\n * Options for Shakespeare constructor\n */\nexport interface ShakespeareOptions {\n  scanner?: IContentScanner;\n  database?: IContentDatabase;\n  ai?: IContentScorer;\n  /** AI model configuration for cost optimization */\n  aiOptions?: AIScorerOptions;\n  /** Default AI model options (provider, model, etc.) */\n  defaultModelOptions?: AIModelOptions;\n  /** Content collection configuration */\n  contentCollection?: ContentCollectionConfig | keyof typeof CONTENT_COLLECTIONS;\n}\n\n// ShakespeareConfig is now imported from types/interfaces.ts\n\n/**\n * Result of a workflow operation\n */\nexport interface WorkflowResult {\n  /** Successfully processed items */\n  successful: string[];\n  /** Failed items with error messages */\n  failed: { path: string; error: string }[];\n  /** Summary statistics */\n  summary: {\n    total: number;\n    succeeded: number;\n    failed: number;\n    duration: number;\n  };\n}\n\nexport class Shakespeare {\n  private scanner: IContentScanner;\n  private _db: IContentDatabase;\n  private ai: IContentScorer;\n  private rootDir: string;\n  private dbPath: string;\n  public logger: ShakespeareLogger;\n  private verbose: boolean = false;\n  \n  /** Configuration used to create this instance */\n  public readonly config: ShakespeareConfig;\n  \n  /** Model options being used for AI operations */\n  public readonly modelOptions?: AIModelOptions;\n\n  /**\n   * Get database instance for testing purposes\n   * @internal\n   */\n  get db(): IContentDatabase {\n    return this._db;\n  }\n\n  constructor(rootDir: string = process.cwd(), dbPath?: string, options: ShakespeareOptions = {}) {\n    this.rootDir = rootDir;\n    this.dbPath = dbPath ?? path.join(rootDir, '.shakespeare', 'content-db.json');\n    \n    // Initialize logger with rootDir for error log placement\n    this.logger = new ShakespeareLogger(rootDir);\n    \n    // Store configuration for public access (rootDir is not part of config)\n    this.config = {\n      dbPath,\n      contentCollection: options.contentCollection,\n      verbose: false, // Will be updated by setVerbose() if needed\n      model: options.defaultModelOptions?.model,\n      provider: options.defaultModelOptions?.provider,\n      modelOptions: options.defaultModelOptions\n    };\n    this.modelOptions = options.defaultModelOptions;\n    \n    // Create scanner with content collection configuration\n    this.scanner = options.scanner ?? new ContentScanner(rootDir, options.contentCollection);\n    this._db = options.database ?? new ContentDatabaseHandler(this.dbPath);\n    \n    // Create AI scorer with proper configuration for cost optimization\n    if (options.ai) {\n      this.ai = options.ai;\n    } else {\n      // Create AIScorer with cost-optimized configuration\n      let aiScorerOptions: AIScorerOptions = {};\n      \n      if (options.aiOptions) {\n        aiScorerOptions = options.aiOptions;\n      } else if (options.defaultModelOptions) {\n        // Create a GooseAI instance with the specified model options and logger\n        const gooseAI = new GooseAI(rootDir, options.defaultModelOptions, this.logger);\n        aiScorerOptions = { \n          ai: gooseAI, \n          defaultModelOptions: options.defaultModelOptions\n        };\n      } else {\n        // Create default GooseAI with logger\n        const gooseAI = new GooseAI(rootDir, {}, this.logger);\n        aiScorerOptions = { ai: gooseAI };\n      }\n      \n      this.ai = new AIScorer(aiScorerOptions);\n    }\n\n    // Database directory creation will be handled during first database operation\n  }\n\n  /**\n   * Initialize the system\n   */\n  async initialize(): Promise<void> {\n    await this._db.load();\n  }\n\n  /**\n   * Discover and index content without scoring (lightweight operation)\n   * Creates database entries for new files with 'needs_review' status\n   */\n  async discoverContent(): Promise<string[]> {\n    const files = await this.scanner.scanContent();\n    const database = this._db.getData();\n    const newFiles: string[] = [];\n\n    for (const file of files) {\n      if (!database.entries[file]) {\n        // Create lightweight entry without AI scoring\n        const newEntry: ContentEntry = {\n          path: file,\n          currentScores: {\n            readability: 0,\n            seoScore: 0,\n            technicalAccuracy: 0,\n            engagement: 0,\n            contentDepth: 0\n          },\n          targetScores: DEFAULT_TARGET_SCORES,\n          lastReviewDate: new Date().toISOString(),\n          improvementIterations: 0,\n          status: 'needs_review', // Mark as unreviewed\n          reviewHistory: [],\n          costAccounting: {\n            reviewCosts: 0,\n            improvementCosts: 0,\n            generationCosts: 0,\n            totalCost: 0,\n            operationHistory: [],\n            lastUpdated: new Date().toISOString()\n          }\n        };\n\n        await this._db.updateEntry(file, (_entry: ContentEntry | undefined) => newEntry);\n        newFiles.push(file);\n      }\n    }\n\n    // Update database timestamp\n    await this._db.save();\n    \n    return newFiles;\n  }\n\n  /**\n   * Update content index with new files\n   */\n  async updateContentIndex(): Promise<void> {\n    const files = await this.scanner.scanContent();\n    const database = this._db.getData();\n\n    for (const file of files) {\n      if (!database.entries[file]) {\n        // Initialize new content entry\n        const content = await this.scanner.readContent(file);\n        const scoringResult = await this.ai.scoreContent(content);\n        const analysis = scoringResult.analysis;\n\n        const newEntry: ContentEntry = {\n          path: file,\n          currentScores: analysis.scores,\n          targetScores: DEFAULT_TARGET_SCORES,\n          lastReviewDate: new Date().toISOString(),\n          improvementIterations: 0,\n          status: this.determineStatus(analysis.scores),\n          reviewHistory: [{\n            date: new Date().toISOString(),\n            scores: analysis.scores,\n            improvements: []\n          }],\n          costAccounting: {\n            reviewCosts: 0,\n            improvementCosts: 0,\n            generationCosts: 0,\n            totalCost: 0,\n            operationHistory: [],\n            lastUpdated: new Date().toISOString()\n          }\n        };\n\n        await this._db.updateEntry(file, (_entry: ContentEntry | undefined) => newEntry);\n        \n        // Track the initial review cost\n        if (scoringResult.costInfo) {\n          await this._db.addOperationCost(file, 'review', scoringResult.costInfo);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the current database data\n   */\n  getDatabaseData() {\n    return this._db.getData();\n  }\n\n  /**\n   * Get content that needs review (unreviewed/discovered content)\n   * @deprecated Use getContentNeedingReviewDetails() for full content objects\n   */\n  getContentNeedingReview(): string[] {\n    // Ensure database is loaded\n    if (!this._db.getData().lastUpdated) {\n      this.logger.warn('Database not loaded. Call initialize() first.');\n    }\n    const database = this._db.getData();\n    return Object.entries(database.entries || {})\n      .filter(([_, entry]) => entry.status === 'needs_review')\n      .map(([path, _]) => path);\n  }\n\n  /**\n   * Get detailed content objects that need review\n   */\n  getContentNeedingReviewDetails(): ContentEntry[] {\n    // Ensure database is loaded\n    if (!this._db.getData().lastUpdated) {\n      this.logger.warn('Database not loaded. Call initialize() first.');\n    }\n    const database = this._db.getData();\n    return Object.entries(database.entries || {})\n      .filter(([_, entry]) => entry.status === 'needs_review')\n      .map(([_, entry]) => entry);\n  }\n\n  /**\n   * Get content entries by status\n   */\n  getContentByStatus(status: ContentStatus): ContentEntry[] {\n    // Ensure database is loaded\n    if (!this._db.getData().lastUpdated) {\n      this.logger.warn('Database not loaded. Call initialize() first.');\n    }\n    const database = this._db.getData();\n    return Object.entries(database.entries || {})\n      .filter(([_, entry]) => entry.status === status)\n      .map(([_, entry]) => entry);\n  }\n\n  /**\n   * Review/score a specific content file\n   * This is a convenience method that delegates to batch processing with a single item\n   */\n  async reviewContent(path: string): Promise<void> {\n    const result = await this.reviewContentBatch([path], 1);\n    \n    // If the single item failed, throw the error to maintain the original API contract\n    if (result.failed.length > 0) {\n      throw new Error(result.failed[0].error);\n    }\n  }\n\n  /**\n   * Calculate overall quality score from quality dimensions\n   */\n  private calculateOverallQuality(scores: QualityDimensions): number {\n    const values = Object.values(scores);\n    return values.reduce((sum, score) => sum + score, 0) / values.length;\n  }\n\n  /**\n   * Get the entry with the lowest average score (excludes unreviewed content)\n   */\n  getWorstScoringContent(): string | null {\n    const database = this._db.getData();\n    let worstScore = Infinity;\n    let worstPath: string | null = null;\n\n    for (const [path, entry] of Object.entries(database.entries)) {\n      // Skip content that meets targets or hasn't been reviewed yet\n      if (entry.status === 'meets_targets' || entry.status === 'needs_review') continue;\n\n      const avgScore = this.calculateOverallQuality(entry.currentScores);\n\n      // Also skip content with zero scores (unreviewed)\n      if (avgScore === 0) continue;\n\n      if (avgScore < worstScore) {\n        worstScore = avgScore;\n        worstPath = path;\n      }\n    }\n\n    return worstPath;\n  }\n\n  /**\n   * Improve content at the specified path\n   * This is a convenience method that delegates to batch processing with a single item\n   */\n  async improveContent(filePath: string): Promise<void> {\n    const result = await this.improveContentBatch([filePath], 1);\n    \n    // If the single item failed, throw the error to maintain the original API contract\n    if (result.failed.length > 0) {\n      throw new Error(result.failed[0].error);\n    }\n  }\n\n  /**\n   * Determine content status based on scores\n   */\n  private determineStatus(scores: QualityDimensions): ContentEntry['status'] {\n    const avgScore = Object.values(scores).reduce((a, b) => a + b, 0) / \n      Object.keys(scores).length;\n\n    if (avgScore >= 8.5) return 'meets_targets';\n    if (avgScore >= 7.0) return 'needs_improvement';\n    return 'needs_review';\n  }\n\n  /**\n   * Set verbose logging for progress reporting\n   */\n  setVerbose(verbose: boolean): void {\n    this.verbose = verbose;\n    this.logger.setVerbose(verbose);\n    // Update the public config to reflect the change\n    (this.config as any).verbose = verbose;\n  }\n\n  /**\n   * Get current verbose setting\n   */\n  isVerbose(): boolean {\n    return this.verbose;\n  }\n\n  /**\n   * Get current model options being used\n   */\n  getModelOptions(): AIModelOptions | undefined {\n    return this.modelOptions;\n  }\n\n  /**\n   * Log message using structured logger\n   * @param message - The message to log\n   * @param level - Log level: 'always' (always log), 'verbose' (only when verbose), 'debug' (extra detail)\n   */\n  private log(message: string, level: 'always' | 'verbose' | 'debug' = 'verbose'): void {\n    switch (level) {\n      case 'always':\n        this.logger.always(message);\n        break;\n      case 'verbose':\n        this.logger.verbose(message);\n        break;\n      case 'debug':\n        this.logger.debug(message);\n        break;\n    }\n  }\n\n  // ========== BATCH PROCESSING METHODS ==========\n\n  /**\n   * Review multiple files in batch with optimized AI operations\n   */\n  async reviewContentBatch(filePaths: string[], batchSize: number = 5): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log(`\uD83D\uDCCA Starting batch review of ${filePaths.length} files (batch size: ${batchSize})`, 'always');\n    \n    await this.initialize();\n    const successful: string[] = [];\n    const failed: { path: string; error: string }[] = [];\n    \n    // Process files in batches\n    for (let i = 0; i < filePaths.length; i += batchSize) {\n      const batch = filePaths.slice(i, i + batchSize);\n      const batchNumber = Math.floor(i / batchSize) + 1;\n      const totalBatches = Math.ceil(filePaths.length / batchSize);\n      \n      this.log(`\uD83D\uDCE6 Processing batch ${batchNumber}/${totalBatches} (${batch.length} files)`, 'always');\n      \n      // Process batch concurrently with controlled concurrency\n      const batchPromises = batch.map(async (filePath) => {\n        try {\n          this.log(`\uD83D\uDCCA Reviewing ${path.basename(filePath)}`, 'verbose');\n          \n          // Business logic moved from reviewContent method\n          const database = this._db.getData();\n          const entry = database.entries[filePath];\n          \n          if (!entry) {\n            throw new Error(`Content not found: ${filePath}`);\n          }\n\n          if (entry.status !== 'needs_review') {\n            throw new Error(`Content has already been reviewed: ${filePath}`);\n          }\n\n          // Score the content with AI\n          const content = await this.scanner.readContent(filePath);\n          const analysis = await this.ai.scoreContent(content);\n\n          // Update entry with scores and proper status\n          const updatedEntry: ContentEntry = {\n            ...entry,\n            currentScores: analysis.analysis.scores,\n            lastReviewDate: new Date().toISOString(),\n            status: this.determineStatus(analysis.analysis.scores),\n            reviewHistory: [{\n              date: new Date().toISOString(),\n              scores: analysis.analysis.scores,\n              improvements: []\n            }]\n          };\n\n          await this._db.updateEntry(filePath, () => updatedEntry);\n          \n          // Track the review cost\n          if (analysis.costInfo) {\n            await this._db.addOperationCost(filePath, 'review', analysis.costInfo);\n          }\n          \n          await this._db.save();\n          \n          return { path: filePath, success: true };\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.log(`\u274C Failed to review ${path.basename(filePath)}: ${errorMessage}`, 'always');\n          return { path: filePath, success: false, error: errorMessage };\n        }\n      });\n      \n      // Wait for batch to complete\n      const batchResults = await Promise.all(batchPromises);\n      \n      // Collect results\n      batchResults.forEach(result => {\n        if (result.success) {\n          successful.push(result.path);\n          this.log(`\u2705 Reviewed: ${path.basename(result.path)}`, 'verbose');\n        } else {\n          failed.push({ path: result.path, error: result.error || 'Unknown error' });\n        }\n      });\n      \n      // Brief pause between batches to avoid overwhelming APIs\n      if (i + batchSize < filePaths.length) {\n        this.log('\u23F8\uFE0F  Pausing between batches...', 'debug');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n    \n    const duration = Date.now() - startTime;\n    this.log(`\uD83C\uDF89 Batch review completed: ${successful.length} succeeded, ${failed.length} failed`, 'always');\n    \n    if (this.verbose) {\n      this.log(`   \u23F1\uFE0F  Total time: ${duration}ms (${Math.round(duration / 1000 * 10) / 10}s)`);\n      this.log(`   \u26A1 Average time per file: ${Math.round(duration / filePaths.length)}ms`);\n      this.log(`   \uD83D\uDCE6 Files per batch: ${batchSize}`);\n    }\n    \n    return {\n      successful,\n      failed,\n      summary: {\n        total: filePaths.length,\n        succeeded: successful.length,\n        failed: failed.length,\n        duration\n      }\n    };\n  }\n\n  /**\n   * Improve multiple files in batch\n   */\n  async improveContentBatch(filePaths: string[], batchSize: number = 3): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log(`\uD83D\uDE80 Starting batch improvement of ${filePaths.length} files (batch size: ${batchSize})`, 'always');\n    \n    await this.initialize();\n    const successful: string[] = [];\n    const failed: { path: string; error: string }[] = [];\n    \n    // Process files in batches (smaller batches for improvement due to higher cost/complexity)\n    for (let i = 0; i < filePaths.length; i += batchSize) {\n      const batch = filePaths.slice(i, i + batchSize);\n      const batchNumber = Math.floor(i / batchSize) + 1;\n      const totalBatches = Math.ceil(filePaths.length / batchSize);\n      \n      this.log(`\uD83D\uDCE6 Processing improvement batch ${batchNumber}/${totalBatches} (${batch.length} files)`, 'always');\n      \n      // Process batch concurrently\n      const batchPromises = batch.map(async (filePath) => {\n        try {\n          this.log(`\uD83D\uDCDD Improving ${path.basename(filePath)}`, 'verbose');\n          \n          // Business logic moved from improveContent method\n          // Ensure database is loaded\n          await this._db.load();\n          \n          const database = this._db.getData();\n          this.logger.debug(`\uD83D\uDD0D Looking for entry with path: ${filePath}`);\n          this.logger.debug(`\uD83D\uDD0D Available database entries: ${Object.keys(database.entries).join(', ')}`);\n          \n          // Try to find the entry with the exact path first\n          let entry = database.entries[filePath];\n          \n          // If not found, try to resolve the path to absolute and look again\n          if (!entry) {\n            const absolutePath = path.resolve(this.rootDir, filePath);\n            this.logger.debug(`\uD83D\uDD0D Trying absolute path: ${absolutePath}`);\n            entry = database.entries[absolutePath];\n          }\n\n          if (!entry) {\n            throw new Error(`No content found at path: ${filePath}. Available paths: ${Object.keys(database.entries).join(', ')}`);\n          }\n\n          // Use the absolute path from the entry for all file operations\n          const absoluteFilePath = entry.path;\n          this.logger.debug(`\uD83D\uDD0D Using absolute path from entry: ${absoluteFilePath}`);\n          \n          // Read current content\n          const content = await this.scanner.readContent(absoluteFilePath);\n          \n          // Get current analysis\n          const analysis = await this.ai.scoreContent(content);\n          \n          // Get the database key for cost tracking\n          const databaseKey = Object.keys(database.entries).find(key => database.entries[key] === entry);\n          if (!databaseKey) {\n            throw new Error(`Could not find database key for entry with path: ${absoluteFilePath}`);\n          }\n          \n          // Track the review cost (for scoring before improvement)\n          if (analysis.costInfo) {\n            await this._db.addOperationCost(databaseKey, 'review', analysis.costInfo);\n          }\n          \n          // Generate improved content - single code path, no fallbacks\n          this.logger.info(`\uD83D\uDCDD Attempting to improve content with ${content.length} characters...`);\n          \n          // Get workflow-specific model options array for improvement (includes fallbacks)\n          const modelOptionsArray = await this.getWorkflowModelOptions('improve');\n          \n          // Call the unified improveContent method with model array and file path\n          const response = await (this.ai as any).improveContentWithModels(content, analysis.analysis, modelOptionsArray, absoluteFilePath);\n          const improvedContent = response.content;\n          \n          this.logger.info(`\u2705 Content improvement successful, got ${improvedContent.length} characters back`);\n          \n          // Validation is now handled inside ai.improveContent(), but we can still check for identical content\n          if (improvedContent === content) {\n            this.logger.warn('\u26A0\uFE0F  Warning: Improved content is identical to original');\n          }\n          \n          // Score the improved content\n          const newScoringResult = await this.ai.scoreContent(improvedContent);\n          const newAnalysis = newScoringResult.analysis;\n          \n          // Calculate quality improvement for ROI tracking\n          const qualityBefore = this.calculateOverallQuality(analysis.analysis.scores);\n          const qualityAfter = this.calculateOverallQuality(newAnalysis.scores);\n          \n          // Track the improvement cost with quality metrics\n          if (response.costInfo) {\n            await this._db.addOperationCost(\n              databaseKey, \n              'improve', \n              response.costInfo, \n              qualityBefore, \n              qualityAfter\n            );\n          }\n          \n          // Track the cost for scoring the improved content\n          if (newScoringResult.costInfo) {\n            await this._db.addOperationCost(databaseKey, 'review', newScoringResult.costInfo);\n          }\n          \n          // Update the content file\n          try {\n            // Use the absolute path from the entry\n            if (!path.isAbsolute(absoluteFilePath)) {\n              throw new Error(`Expected absolute path from database entry, but got relative path: ${absoluteFilePath}`);\n            }\n            \n            this.logger.debug(`\uD83D\uDD0D Writing improved content to: ${absoluteFilePath}`);\n            await fs.writeFile(absoluteFilePath, improvedContent, 'utf-8');\n            this.logger.info(`\uD83D\uDCC4 Successfully wrote improved content to ${absoluteFilePath}`);\n          } catch (writeError) {\n            const errorMessage = writeError instanceof Error ? writeError.message : String(writeError);\n            this.logger.error(`\u274C Failed to write improved content to file: ${errorMessage}`);\n            throw writeError;\n          }\n          \n          // Update database entry - use the path that was found in the database (already resolved above)\n          \n          await this._db.updateEntry(databaseKey, (entry: ContentEntry | undefined) => {\n            if (!entry) {\n              throw new Error(`Entry not found for path: ${databaseKey}`);\n            }\n            return {\n              ...entry,\n              currentScores: newAnalysis.scores,\n              lastReviewDate: new Date().toISOString(),\n              improvementIterations: entry.improvementIterations + 1,\n              status: this.determineStatus(newAnalysis.scores),\n              reviewHistory: [\n                ...entry.reviewHistory,\n                {\n                  date: new Date().toISOString(),\n                  scores: newAnalysis.scores,\n                  improvements: Object.values(analysis.analysis).flatMap(a => a.suggestions)\n                }\n              ]\n            };\n          });\n          \n          return { path: filePath, success: true };\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.log(`\u274C Failed to improve ${path.basename(filePath)}: ${errorMessage}`, 'always');\n          return { path: filePath, success: false, error: errorMessage };\n        }\n      });\n      \n      // Wait for batch to complete\n      const batchResults = await Promise.all(batchPromises);\n      \n      // Collect results\n      batchResults.forEach(result => {\n        if (result.success) {\n          successful.push(result.path);\n          this.log(`\u2705 Improved: ${path.basename(result.path)}`, 'verbose');\n        } else {\n          failed.push({ path: result.path, error: result.error || 'Unknown error' });\n        }\n      });\n      \n      // Longer pause between improvement batches (more expensive operations)\n      if (i + batchSize < filePaths.length) {\n        this.log('\u23F8\uFE0F  Pausing between improvement batches...', 'debug');\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    \n    const duration = Date.now() - startTime;\n    this.log(`\uD83C\uDF89 Batch improvement completed: ${successful.length} succeeded, ${failed.length} failed`, 'always');\n    \n    if (this.verbose) {\n      this.log(`   \u23F1\uFE0F  Total time: ${duration}ms (${Math.round(duration / 1000 * 10) / 10}s)`);\n      this.log(`   \u26A1 Average time per file: ${Math.round(duration / filePaths.length)}ms`);\n      this.log(`   \uD83D\uDCE6 Files per batch: ${batchSize}`);\n    }\n    \n    return {\n      successful,\n      failed,\n      summary: {\n        total: filePaths.length,\n        succeeded: successful.length,\n        failed: failed.length,\n        duration\n      }\n    };\n  }\n\n  /**\n   * Review all content using batch processing for better performance\n   */\n  async reviewAllBatch(batchSize: number = 5): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    \n    // Get model configuration for review workflow\n    const reviewOptionsArray = await this.getWorkflowModelOptions('review');\n    const primaryModel = reviewOptionsArray[0];\n    const modelInfo = primaryModel ? \n      `${primaryModel.provider || 'default'}${primaryModel.model ? `/${primaryModel.model}` : ''}` : \n      'default';\n    \n    this.log(`\uD83D\uDCCA Starting batch content review using ${modelInfo}...`, 'always');\n    \n    await this.initialize();\n    const database = this._db.getData();\n    const allEntries = Object.entries(database.entries || {});\n    const contentNeedingReview = allEntries\n      .filter(([, entry]) => entry.status === 'needs_review')\n      .map(([path]) => path);\n\n    if (contentNeedingReview.length === 0) {\n      this.log('\u2705 No content needs review', 'always');\n      return {\n        successful: [],\n        failed: [],\n        summary: { total: 0, succeeded: 0, failed: 0, duration: Date.now() - startTime }\n      };\n    }\n\n    this.log(`\uD83D\uDCDD Found ${contentNeedingReview.length} files needing review`, 'always');\n    this.log(`\uD83D\uDCE6 Using batch size: ${batchSize}`, 'verbose');\n    \n    // Use the batch processing method\n    const result = await this.reviewContentBatch(contentNeedingReview, batchSize);\n    \n    // Update summary with total time\n    result.summary.duration = Date.now() - startTime;\n    \n    return result;\n  }\n\n  /**\n   * Improve worst-scoring content using batch processing\n   */\n  async improveWorstBatch(count: number = 5, batchSize: number = 3): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log(`\uD83D\uDE80 Starting batch improvement of ${count} worst-scoring content (batch size: ${batchSize})...`, 'always');\n    \n    await this.initialize();\n    const database = this._db.getData();\n    \n    // Get worst-scoring files\n    const worstFiles: string[] = [];\n    const entries = Object.entries(database.entries);\n    \n    // Sort by average score (ascending) to get worst first\n    const scoredEntries = entries\n      .filter(([, entry]) => entry.status !== 'needs_review' && entry.status !== 'meets_targets')\n      .map(([path, entry]) => {\n        const scores = Object.values(entry.currentScores);\n        const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;\n        return { path, avgScore, entry };\n      })\n      .filter(({ avgScore }) => avgScore > 0) // Exclude unreviewed content\n      .sort((a, b) => a.avgScore - b.avgScore);\n    \n    // Take the worst N files\n    for (let i = 0; i < Math.min(count, scoredEntries.length); i++) {\n      worstFiles.push(scoredEntries[i].path);\n    }\n    \n    if (worstFiles.length === 0) {\n      this.log('\u2705 No content needs improvement', 'always');\n      return {\n        successful: [],\n        failed: [],\n        summary: { total: 0, succeeded: 0, failed: 0, duration: Date.now() - startTime }\n      };\n    }\n    \n    this.log(`\uD83D\uDCCB Selected ${worstFiles.length} files for improvement:`, 'verbose');\n    worstFiles.forEach((file, index) => {\n      const entry = scoredEntries.find(e => e.path === file);\n      this.log(`   ${index + 1}. ${path.basename(file)} (score: ${entry?.avgScore.toFixed(1)})`, 'verbose');\n    });\n    \n    // Use batch processing for improvements\n    const result = await this.improveContentBatch(worstFiles, batchSize);\n    \n    // Update summary with total time\n    result.summary.duration = Date.now() - startTime;\n    \n    return result;\n  }\n\n  // ========== HIGH-LEVEL WORKFLOW METHODS ==========\n\n  /**\n   * Discover content and provide detailed reporting\n   */\n  async discoverAndReport(): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log('\uD83D\uDD0D Starting content discovery...');\n    \n    try {\n      const discovered = await this.discoverContent();\n      const duration = Date.now() - startTime;\n      \n      this.log(`\uD83D\uDCCA Discovery completed: ${discovered.length} files found`);\n      if (discovered.length > 0) {\n        discovered.forEach(file => this.log(`  \uD83D\uDCC4 ${path.basename(file)}`));\n      }\n      \n      return {\n        successful: discovered,\n        failed: [],\n        summary: {\n          total: discovered.length,\n          succeeded: discovered.length,\n          failed: 0,\n          duration\n        }\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.log(`\u274C Discovery failed: ${errorMessage}`);\n      \n      return {\n        successful: [],\n        failed: [{ path: 'discovery', error: errorMessage }],\n        summary: {\n          total: 0,\n          succeeded: 0,\n          failed: 1,\n          duration: Date.now() - startTime\n        }\n      };\n    }\n  }\n\n  /**\n   * Review all content that needs review\n   */\n  async reviewAll(): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log('\uD83D\uDCCA Starting content review...', 'always');\n    \n    // Show configuration details in verbose mode\n    if (this.verbose) {\n      this.log('\uD83D\uDD27 Configuration Details:');\n      this.log(`   Root Directory: ${this.rootDir}`);\n      this.log(`   Database Path: ${this.dbPath}`);\n      this.log(`   Content Collection: ${this.config.contentCollection || 'auto-detected'}`);\n      this.log(`   Model: ${this.config.model || 'default'}`);\n      this.log(`   Provider: ${this.config.provider || 'default'}`);\n      this.log(`   Verbose Mode: ${this.verbose ? '\u2713 enabled' : '\u2717 disabled'}`);\n      this.log('');\n    }\n    \n    await this.initialize();\n    const database = this._db.getData();\n    \n    this.log('\uD83D\uDCCB Database Status:', 'always');\n    this.log(`   Total entries: ${Object.keys(database.entries || {}).length}`, 'always');\n    this.log(`   Last updated: ${database.lastUpdated || 'never'}`, 'always');\n    \n    const allEntries = Object.entries(database.entries || {});\n    const statusCounts = allEntries.reduce((counts, [, entry]) => {\n      counts[entry.status] = (counts[entry.status] || 0) + 1;\n      return counts;\n    }, {} as Record<string, number>);\n    \n    this.log('   Status breakdown:', 'always');\n    Object.entries(statusCounts).forEach(([status, count]) => {\n      this.log(`     ${status}: ${count}`, 'always');\n    });\n    this.log('', 'always');\n    \n    const contentNeedingReview = allEntries\n      .filter(([, entry]) => entry.status === 'needs_review')\n      .map(([path]) => path);\n\n    if (contentNeedingReview.length === 0) {\n      this.log('\u2705 No content needs review', 'always');\n      return {\n        successful: [],\n        failed: [],\n        summary: { total: 0, succeeded: 0, failed: 0, duration: Date.now() - startTime }\n      };\n    }\n\n    this.log(`\uD83D\uDCDD Found ${contentNeedingReview.length} files needing review`, 'always');\n    \n    if (this.verbose) {\n      this.log('\uD83D\uDCC2 Files to review:');\n      contentNeedingReview.forEach((filePath, index) => {\n        this.log(`   ${index + 1}. ${path.basename(filePath)}`);\n      });\n      this.log('');\n    }\n\n    const successful: string[] = [];\n    const failed: { path: string; error: string }[] = [];\n    let totalFileSize = 0;\n    let totalScoreTime = 0;\n\n    for (let i = 0; i < contentNeedingReview.length; i++) {\n      const filePath = contentNeedingReview[i];\n      const fileStartTime = Date.now();\n      \n      try {\n        this.log(`\uD83D\uDCCA Reviewing ${path.basename(filePath)} (${i + 1}/${contentNeedingReview.length})`, 'always');\n        \n        if (this.verbose) {\n          // Show file details\n          try {\n            const fs = await import('fs/promises');\n            const stats = await fs.stat(filePath);\n            const fileSize = Math.round(stats.size / 1024 * 10) / 10; // KB with 1 decimal\n            totalFileSize += stats.size;\n            this.log(`   \uD83D\uDCC4 File size: ${fileSize} KB`, 'debug');\n            this.log(`   \uD83D\uDCC5 Last modified: ${stats.mtime.toISOString()}`, 'debug');\n          } catch (statError) {\n            this.log(`   \u26A0\uFE0F Could not read file stats: ${statError}`, 'debug');\n          }\n        }\n        \n        const reviewStartTime = Date.now();\n        await this.reviewContent(filePath);\n        const reviewDuration = Date.now() - reviewStartTime;\n        totalScoreTime += reviewDuration;\n        \n        // Get updated entry to show scores\n        const updatedDatabase = this._db.getData();\n        const updatedEntry = updatedDatabase.entries[filePath];\n        \n        successful.push(filePath);\n        const fileDuration = Date.now() - fileStartTime;\n        this.log(`\u2705 Reviewed: ${path.basename(filePath)} (${fileDuration}ms)`, 'always');\n        \n        if (this.verbose && updatedEntry) {\n          this.log('   \uD83D\uDCCA Quality Scores:');\n          this.log(`      Readability: ${updatedEntry.currentScores.readability}/10`);\n          this.log(`      SEO Score: ${updatedEntry.currentScores.seoScore}/10`);\n          this.log(`      Technical Accuracy: ${updatedEntry.currentScores.technicalAccuracy}/10`);\n          this.log(`      Engagement: ${updatedEntry.currentScores.engagement}/10`);\n          this.log(`      Content Depth: ${updatedEntry.currentScores.contentDepth}/10`);\n          \n          const avgScore = this.calculateOverallQuality(updatedEntry.currentScores);\n          this.log(`   \uD83C\uDFAF Average Score: ${Math.round(avgScore * 10) / 10}/10`);\n          this.log(`   \u23F1\uFE0F Review Time: ${reviewDuration}ms`, 'debug');\n        }\n        \n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        failed.push({ path: filePath, error: errorMessage });\n        const fileDuration = Date.now() - fileStartTime;\n        this.log(`\u274C Failed to review ${path.basename(filePath)} (${fileDuration}ms): ${errorMessage}`, 'always');\n        \n        if (this.verbose) {\n          this.log(`   \uD83D\uDD0D Error details: ${error instanceof Error ? error.stack : errorMessage}`, 'debug');\n        }\n      }\n      \n      // Progress indicator\n      const progress = Math.round((i + 1) / contentNeedingReview.length * 100);\n      if (this.verbose) {\n        this.log(`   \uD83D\uDCC8 Progress: ${progress}% (${i + 1}/${contentNeedingReview.length})`, 'debug');\n        this.log('', 'debug');\n      }\n    }\n\n    const duration = Date.now() - startTime;\n    this.log(`\uD83C\uDF89 Review completed: ${successful.length} succeeded, ${failed.length} failed`, 'always');\n    \n    if (this.verbose) {\n      this.log('\uD83D\uDCCA Summary Statistics:');\n      this.log(`   \u23F1\uFE0F Total time: ${duration}ms (${Math.round(duration / 1000 * 10) / 10}s)`);\n      this.log(`   \uD83D\uDCC4 Total file size: ${Math.round(totalFileSize / 1024 * 10) / 10} KB`);\n      this.log(`   \uD83E\uDD16 Total scoring time: ${totalScoreTime}ms`);\n      this.log(`   \u26A1 Average time per file: ${Math.round(duration / contentNeedingReview.length)}ms`);\n      \n      if (successful.length > 0) {\n        this.log(`   \u2705 Success rate: ${Math.round(successful.length / contentNeedingReview.length * 100)}%`);\n      }\n      \n      if (failed.length > 0) {\n        this.log('   \u274C Failed files:');\n        failed.forEach(({path: filePath, error}) => {\n          this.log(`      ${path.basename(filePath)}: ${error}`);\n        });\n      }\n    }\n\n    return {\n      successful,\n      failed,\n      summary: {\n        total: contentNeedingReview.length,\n        succeeded: successful.length,\n        failed: failed.length,\n        duration\n      }\n    };\n  }\n\n  /**\n   * Improve the worst-scoring content\n   */\n  async improveWorst(count: number = 1): Promise<WorkflowResult> {\n    const startTime = Date.now();\n    this.log(`\uD83D\uDE80 Starting improvement of ${count} worst-scoring content...`);\n    \n    await this.initialize();\n    const successful: string[] = [];\n    const failed: { path: string; error: string }[] = [];\n\n    for (let i = 0; i < count; i++) {\n      try {\n        const worstPath = this.getWorstScoringContent();\n        if (!worstPath) {\n          this.log('\u2705 No content needs improvement');\n          break;\n        }\n\n        this.log(`\uD83D\uDCDD Improving ${path.basename(worstPath)} (${i + 1}/${count})`);\n        await this.improveContent(worstPath);\n        successful.push(worstPath);\n        this.log(`\u2705 Improved: ${path.basename(worstPath)}`);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        failed.push({ path: 'improvement', error: errorMessage });\n        this.log(`\u274C Improvement failed: ${errorMessage}`);\n      }\n    }\n\n    const duration = Date.now() - startTime;\n    this.log(`\uD83C\uDF89 Improvement completed: ${successful.length} succeeded, ${failed.length} failed`);\n\n    return {\n      successful,\n      failed,\n      summary: {\n        total: count,\n        succeeded: successful.length,\n        failed: failed.length,\n        duration\n      }\n    };\n  }\n\n  /**\n   * Run the complete workflow: discover -> review -> improve\n   */\n  async runFullWorkflow(options: { improveCount?: number } = {}): Promise<{\n    discovery: WorkflowResult;\n    review: WorkflowResult;\n    improvement: WorkflowResult;\n  }> {\n    this.log('\uD83C\uDFAD Starting complete Shakespeare workflow...');\n\n    const discovery = await this.discoverAndReport();\n    const review = await this.reviewAll();\n    const improvement = await this.improveWorst(options.improveCount || 1);\n\n    this.log('\uD83C\uDF89 Complete workflow finished!');\n\n    return {\n      discovery,\n      review,\n      improvement\n    };\n  }\n\n  /**\n   * Get detailed ROI analysis for content improvements\n   */\n  async getROIAnalysis(): Promise<{\n    totalInvestment: number;\n    totalQualityGain: number;\n    averageCostPerQualityPoint: number;\n    contentEfficiency: Array<{\n      path: string;\n      investment: number;\n      qualityGain: number;\n      efficiency: number;\n      iterations: number;\n    }>;\n    diminishingReturns: Array<{\n      path: string;\n      iterationEfficiency: Array<{\n        iteration: number;\n        cost: number;\n        qualityGain: number;\n        efficiency: number;\n      }>;\n    }>;\n  }> {\n    await this.initialize();\n    const database = this._db.getData();\n    const costSummary = this._db.getCostSummary();\n    \n    let totalInvestment = 0;\n    let totalQualityGain = 0;\n    const contentEfficiency = [];\n    const diminishingReturns = [];\n    \n    for (const [path, entry] of Object.entries(database.entries)) {\n      if (entry.costAccounting && entry.reviewHistory.length > 0) {\n        const investment = entry.costAccounting.improvementCosts;\n        if (investment > 0) {\n          totalInvestment += investment;\n          \n          // Calculate quality gain from review history\n          let qualityGain = 0;\n          const iterationEfficiency = [];\n          \n          for (let i = 0; i < entry.reviewHistory.length; i++) {\n            const historyEntry = entry.reviewHistory[i];\n            if (historyEntry.improvementMetrics) {\n              const metrics = historyEntry.improvementMetrics;\n              qualityGain += metrics.qualityDelta;\n              totalQualityGain += metrics.qualityDelta;\n              \n              iterationEfficiency.push({\n                iteration: i + 1,\n                cost: historyEntry.costInfo?.cost || 0,\n                qualityGain: metrics.qualityDelta,\n                efficiency: metrics.costPerQualityPoint\n              });\n            }\n          }\n          \n          if (qualityGain > 0) {\n            contentEfficiency.push({\n              path: path,\n              investment,\n              qualityGain,\n              efficiency: investment / qualityGain,\n              iterations: entry.improvementIterations\n            });\n            \n            if (iterationEfficiency.length > 1) {\n              diminishingReturns.push({\n                path: path,\n                iterationEfficiency\n              });\n            }\n          }\n        }\n      }\n    }\n    \n    // Sort by efficiency (lower is better - less cost per quality point)\n    contentEfficiency.sort((a, b) => a.efficiency - b.efficiency);\n    \n    return {\n      totalInvestment,\n      totalQualityGain,\n      averageCostPerQualityPoint: costSummary.averageCostPerQualityPoint,\n      contentEfficiency,\n      diminishingReturns\n    };\n  }\n\n  /**\n   * List interrupted improvement jobs\n   */\n  async listProgressFiles(): Promise<Array<{\n    executionId: string;\n    startTime: string;\n    completedChunks: number;\n    totalChunks: number;\n    totalCost: number;\n    filePath: string;\n  }>> {\n    const progressDir = path.join(this.rootDir, '.shakespeare', 'progress');\n    \n    try {\n      const files = await fs.readdir(progressDir);\n      const progressFiles = [];\n      \n      for (const file of files) {\n        if (file.endsWith('.json')) {\n          const filePath = path.join(progressDir, file);\n          try {\n            const content = await fs.readFile(filePath, 'utf-8');\n            const progress = JSON.parse(content);\n            const executionId = file.replace('.json', '');\n            \n            // Extract start time from execution ID (timestamp format)\n            const timestampMatch = executionId.match(/improve-chunked-(\\d+)/);\n            const startTime = timestampMatch \n              ? new Date(parseInt(timestampMatch[1])).toISOString()\n              : 'Unknown';\n            \n            progressFiles.push({\n              executionId,\n              startTime,\n              completedChunks: progress.improvedChunks?.length || 0,\n              totalChunks: progress.totalChunks || 0,\n              totalCost: progress.totalCost || 0,\n              filePath\n            });\n          } catch (error) {\n            // Skip corrupted progress files\n            continue;\n          }\n        }\n      }\n      \n      // Sort by start time (newest first)\n      return progressFiles.sort((a, b) => \n        new Date(b.startTime).getTime() - new Date(a.startTime).getTime()\n      );\n      \n    } catch (error) {\n      // Directory doesn't exist or can't be read\n      return [];\n    }\n  }\n\n  /**\n   * Resume a progress job by execution ID\n   */\n  async resumeProgressJob(executionId: string): Promise<{\n    totalCost: number;\n    contentLength: number;\n  }> {\n    await this.initialize();\n    \n    // Load progress data to get original content path and other details\n    const progressDir = path.join(this.rootDir, '.shakespeare', 'progress');\n    const progressPath = path.join(progressDir, `${executionId}.json`);\n    \n    let progress: any;\n    try {\n      const content = await fs.readFile(progressPath, 'utf-8');\n      progress = JSON.parse(content);\n    } catch (error) {\n      throw new Error(`Progress file not found for execution ID: ${executionId}`);\n    }\n    \n    if (!progress.originalContent || !progress.analysis) {\n      throw new Error(`Progress file ${executionId} is missing required data (originalContent or analysis)`);\n    }\n    \n    // Resume the AI improvement using the stored data\n    const result = await (this.ai as any).resumeChunkedImprovement(executionId);\n    \n    // Find the database entry to update using stored file path\n    const database = this._db.getData();\n    let matchingEntry: any = null;\n    let databaseKey: string | null = null;\n    \n    if (progress.filePath) {\n      // Try to find by stored file path first\n      databaseKey = Object.keys(database.entries).find(key => \n        database.entries[key].path === progress.filePath\n      ) || null;\n      if (databaseKey) {\n        matchingEntry = database.entries[databaseKey];\n      }\n    }\n    \n    // Fallback: match by content if file path lookup failed\n    if (!matchingEntry || !databaseKey) {\n      for (const [key, entry] of Object.entries(database.entries)) {\n        try {\n          const fileContent = await this.scanner.readContent(entry.path);\n          if (fileContent === progress.originalContent) {\n            matchingEntry = entry;\n            databaseKey = key;\n            break;\n          }\n        } catch {\n          // Skip files that can't be read\n          continue;\n        }\n      }\n    }\n    \n    if (!matchingEntry || !databaseKey) {\n      this.logger.warn(`Could not find matching database entry for resumed job ${executionId}`);\n      // Continue with the improvement but skip database updates\n    }\n    \n    // Update cost tracking in database if we found the entry\n    if (matchingEntry && databaseKey && result.costInfo) {\n      // Calculate quality metrics for the improvement\n      const qualityBefore = this.calculateOverallQuality(progress.analysis.scores);\n      \n      // Score the improved content to get quality after\n      const newAnalysis = await this.ai.scoreContent(result.content);\n      const qualityAfter = this.calculateOverallQuality(newAnalysis.analysis.scores);\n      \n      // Track the improvement cost\n      await this._db.addOperationCost(databaseKey, 'improve', result.costInfo, qualityBefore, qualityAfter);\n      \n      // Track the final scoring cost\n      if (newAnalysis.costInfo) {\n        await this._db.addOperationCost(databaseKey, 'review', newAnalysis.costInfo);\n      }\n      \n      // Update the database entry with new scores and status\n      await this._db.updateEntry(databaseKey, (entry) => {\n        if (!entry) throw new Error(`Entry not found: ${databaseKey}`);\n        \n        return {\n          ...entry,\n          currentScores: newAnalysis.analysis.scores,\n          lastReviewDate: new Date().toISOString(),\n          improvementIterations: entry.improvementIterations + 1,\n          status: this.determineStatus(newAnalysis.analysis.scores),\n          reviewHistory: [\n            ...entry.reviewHistory,\n            {\n              date: new Date().toISOString(),\n              scores: newAnalysis.analysis.scores,\n              improvements: Object.values(newAnalysis.analysis).flatMap((d: any) => d.suggestions || []),\n              costInfo: result.costInfo,\n              improvementMetrics: {\n                scoreBefore: qualityBefore,\n                scoreAfter: qualityAfter,\n                qualityDelta: qualityAfter - qualityBefore,\n                costPerQualityPoint: qualityAfter > qualityBefore ? result.costInfo.totalCost / (qualityAfter - qualityBefore) : 0,\n                iterationNumber: entry.improvementIterations + 1\n              }\n            }\n          ]\n        };\n      });\n      \n      // Write the improved content back to the file\n      if (progress.filePath) {\n        try {\n          await fs.writeFile(progress.filePath, result.content, 'utf-8');\n          this.logger.info(`\uD83D\uDCC4 Successfully wrote improved content to ${progress.filePath}`);\n        } catch (writeError) {\n          const errorMessage = writeError instanceof Error ? writeError.message : String(writeError);\n          this.logger.error(`\u274C Failed to write improved content to file: ${errorMessage}`);\n          throw writeError;\n        }\n      }\n    }\n    \n    // Clean up the progress file since job is complete\n    try {\n      await fs.unlink(progressPath);\n      this.logger.info(`Cleaned up progress file for completed job: ${executionId}`);\n    } catch (error) {\n      this.logger.warn(`Could not clean up progress file: ${error}`);\n    }\n    \n    return {\n      totalCost: result.costInfo.totalCost,\n      contentLength: result.content.length\n    };\n  }\n\n  /**\n   * Get content health status dashboard\n   */\n  async getStatus(): Promise<{\n    totalFiles: number;\n    needsReview: number;\n    needsImprovement: number;\n    meetsTargets: number;\n    averageScore: number;\n    worstScoring: string | null;\n    costSummary: {\n      totalCosts: { review: number; improvement: number; generation: number; total: number };\n      costsByContent: Record<string, any>;\n      averageCostPerQualityPoint: number;\n      totalOperations: number;\n    };\n  }> {\n    await this.initialize();\n    const database = this._db.getData();\n    const entries = Object.entries(database.entries);\n\n    const needsReview = entries.filter(([, entry]) => entry.status === 'needs_review').length;\n    const needsImprovement = entries.filter(([, entry]) => entry.status === 'needs_improvement').length;\n    const meetsTargets = entries.filter(([, entry]) => entry.status === 'meets_targets').length;\n\n    const scores = entries.map(([, entry]) => {\n      const scores = Object.values(entry.currentScores || {});\n      return scores.reduce((a, b) => a + b, 0) / scores.length;\n    }).filter(score => !isNaN(score));\n\n    const averageScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;\n    const worstScoring = this.getWorstScoringContent();\n    \n    // Get cost summary from database\n    const costSummary = this._db.getCostSummary();\n\n    return {\n      totalFiles: entries.length,\n      needsReview,\n      needsImprovement,\n      meetsTargets,\n      averageScore: Math.round(averageScore * 10) / 10,\n      worstScoring,\n      costSummary\n    };\n  }\n\n  // ========== STATIC FACTORY METHODS ==========\n\n  /**\n   * Create Shakespeare instance with smart defaults and auto-detection\n   * @param rootDir - The root directory to operate in\n   * @param config - Configuration options\n   */\n  static async create(rootDir: string, config: ShakespeareConfig = {}): Promise<Shakespeare> {\n    const dbPath = config.dbPath;\n    \n    // Auto-detect project type if not specified\n    const detectedType = await detectProjectType(rootDir);\n    const contentCollection = config.contentCollection || detectedType;\n    \n    // Get optimized model options\n    const defaultModelOptions = getOptimizedModelOptions(config);\n    \n    const options: ShakespeareOptions = {\n      contentCollection,\n      defaultModelOptions\n    };\n    \n    const shakespeare = new Shakespeare(rootDir, dbPath, options);\n    \n    // Store the full configuration that was used to create this instance (without rootDir)\n    (shakespeare.config as any) = {\n      ...shakespeare.config,\n      ...config,\n      contentCollection,\n      model: defaultModelOptions?.model || config.model,\n      provider: defaultModelOptions?.provider || config.provider,\n      modelOptions: defaultModelOptions\n    };\n    // Note: rootDir is not stored in config as it's a runtime parameter\n    \n    if (config.verbose) {\n      shakespeare.setVerbose(true);\n    }\n    \n    if (config.logLevel) {\n      shakespeare.logger.setLevel(config.logLevel);\n    }\n    \n    return shakespeare;\n  }\n\n  /**\n   * Create Shakespeare from configuration file or database config\n   */\n  static async fromConfig(configPath?: string): Promise<Shakespeare> {\n    const { join, dirname, resolve } = await import('path');\n    const { existsSync, readFileSync } = await import('fs');\n    const cwd = process.cwd();\n    \n    // Try to find external config file first\n    const possiblePaths = [\n      configPath,\n      join(cwd, '.shakespeare', 'config.json'),\n      join(cwd, 'shakespeare.config.js'),\n      join(cwd, 'shakespeare.config.mjs'),\n      join(cwd, 'shakespeare.config.json'),\n      join(cwd, '.shakespeare.json')\n    ].filter(Boolean);\n    \n    for (const configFile of possiblePaths) {\n      try {\n        if (existsSync(configFile!)) {\n          let config: ShakespeareConfig;\n          \n          if (configFile!.endsWith('.json')) {\n            config = JSON.parse(readFileSync(configFile!, 'utf-8'));\n          } else {\n            // Dynamic import for JS/MJS files\n            const configModule = await import(configFile!);\n            config = configModule.default || configModule;\n          }\n          \n          try {\n            // Process configuration to extract model/provider info\n            const normalizedConfig = await this.workflowConfigToShakespeareConfig(config);\n            \n            // The root directory should be the project root, not the config directory\n            // For configs in .shakespeare/, use the parent directory\n            let configDir = dirname(resolve(configFile!));\n            if (configFile!.includes('.shakespeare')) {\n              configDir = dirname(configDir);\n            }\n            \n            // Resolve dbPath relative to config file location if provided\n            if (normalizedConfig.dbPath) {\n              normalizedConfig.dbPath = resolve(configDir, normalizedConfig.dbPath);\n            }\n            \n            const shakespeare = await Shakespeare.create(configDir, normalizedConfig);\n            return shakespeare;\n          } catch (error) {\n            if (error instanceof InvalidConfigError) {\n              // Provide helpful error messages for configuration issues\n              new ShakespeareLogger().error(`Failed to load config from ${configFile}: ${error.message}`);\n              throw error;\n            }\n            throw error;\n          }\n        }\n      } catch (error) {\n        // Re-throw validation errors instead of swallowing them\n        if (error instanceof InvalidConfigError) {\n          throw error;\n        }\n        // Only warn and continue for other errors (file not found, parse errors, etc.)\n        new ShakespeareLogger().warn(`Failed to load config from ${configFile}: ${error}`);\n      }\n    }\n    \n    // Try to load configuration from content database\n    try {\n      const dbPath = join(cwd, '.shakespeare', 'content-db.json');\n      if (existsSync(dbPath)) {\n        const db = JSON.parse(readFileSync(dbPath, 'utf-8'));\n        if (db.config) {\n          try {\n            // Process database configuration to extract model/provider info\n            const normalizedConfig = await this.workflowConfigToShakespeareConfig(db.config);\n            // Use current working directory as root when loading from database\n            const shakespeare = await Shakespeare.create(cwd, normalizedConfig);\n            return shakespeare;\n          } catch (error) {\n            if (error instanceof InvalidConfigError) {\n              new ShakespeareLogger().error(`Failed to load config from database: ${error.message}`);\n              throw error;\n            }\n            throw error;\n          }\n        }\n      }\n    } catch (error) {\n      new ShakespeareLogger().warn(`Failed to load config from database: ${error}`);\n    }\n    \n    // Fallback to default configuration with current working directory\n    return await Shakespeare.create(cwd);\n  }\n\n  /**\n   * Convert ShakespeareConfig to ShakespeareConfig\n   */\n  static async workflowConfigToShakespeareConfig(workflowConfig: ShakespeareConfig): Promise<ShakespeareConfig> {\n    const config: ShakespeareConfig = {\n      verbose: workflowConfig.verbose,\n      logLevel: workflowConfig.logLevel\n    };\n\n    // Set content collection if specified\n    if (workflowConfig.contentCollection) {\n      config.contentCollection = workflowConfig.contentCollection;\n    }\n\n    // Copy all other properties from the source config\n    Object.keys(workflowConfig).forEach(key => {\n      if (!['verbose', 'logLevel', 'contentCollection'].includes(key)) {\n        (config as any)[key] = (workflowConfig as any)[key];\n      }\n    });\n\n    // Configure models - use first review model as default since it's most commonly used if no global model\n    if (!config.model && workflowConfig.models?.review) {\n      const reviewModelConfig = workflowConfig.models.review;\n      // Handle both old format and new array format\n      const firstReviewModel = Array.isArray(reviewModelConfig) ? reviewModelConfig[0] : reviewModelConfig;\n      \n      if (typeof firstReviewModel === 'string') {\n        config.model = firstReviewModel;\n      } else if (firstReviewModel && typeof firstReviewModel === 'object') {\n        config.model = firstReviewModel.model;\n        if (firstReviewModel.provider && !config.provider) {\n          config.provider = firstReviewModel.provider;\n        }\n      }\n    }\n\n    // If model is specified, set up model options\n    if (config.model) {\n      config.modelOptions = {\n        model: config.model,\n        provider: config.provider\n      };\n    }\n\n    return config;\n  }\n\n  // ========== WORKFLOW CONFIGURATION METHODS ==========\n\n  /**\n   * Save workflow configuration to the content database\n   */\n  async saveShakespeareConfig(workflowConfig: ShakespeareConfig): Promise<void> {\n    await this._db.load();\n    const currentData = this._db.getData();\n    currentData.config = workflowConfig;\n    await this._db.save();\n    this.log('\uD83D\uDCBE Workflow configuration saved to content database');\n  }\n\n  /**\n   * Get current workflow configuration from database\n   */\n  async getShakespeareConfig(): Promise<ShakespeareConfig | undefined> {\n    await this._db.load();\n    return this._db.getData().config;\n  }\n\n  /**\n   * Get model information as a formatted string for display\n   */\n  async getModelInfoString(workflowType: 'review' | 'improve' | 'generate'): Promise<string> {\n    const modelOptionsArray = await this.getWorkflowModelOptions(workflowType);\n    if (!modelOptionsArray || modelOptionsArray.length === 0) return 'default';\n    \n    const primaryModel = modelOptionsArray[0];\n    const provider = primaryModel.provider || 'default';\n    const model = primaryModel.model ? `/${primaryModel.model}` : '';\n    return `${provider}${model}`;\n  }\n\n  /**\n   * Get workflow-specific model options for an operation type\n   */\n  private async getWorkflowModelOptions(workflowType: 'review' | 'improve' | 'generate'): Promise<AIModelOptions[]> {\n    // First check the current instance config (V2 format)\n    if (this.config.taskModelOptions?.[workflowType]) {\n      return [this.config.taskModelOptions[workflowType]];\n    }\n    \n    // Then check for consolidated models configuration\n    const modelConfig = this.config.models?.[workflowType];\n    if (modelConfig) {\n      if (Array.isArray(modelConfig)) {\n        // New array format: try each model in order\n        return modelConfig.map(config => {\n          if (typeof config === 'string') {\n            return { model: config };\n          } else {\n            return {\n              model: config.model,\n              provider: config.provider\n            };\n          }\n        });\n      } else if (typeof modelConfig === 'string') {\n        // Backward compatibility: string model name\n        return [{ model: modelConfig }];\n      } else {\n        // Single object format: object with model and optional provider\n        return [{\n          model: modelConfig.model,\n          provider: modelConfig.provider\n        }];\n      }\n    }\n    \n\n    // Provide sensible defaults when no configuration is found (with fallback)\n    const defaults = {\n      review: [\n        { model: 'gpt-4o-mini', provider: 'tetrate' }, // Fast, cost-effective for scoring\n        { model: 'gemini-1.5-flash-8b', provider: 'google' } // Fallback\n      ],\n      improve: [\n        { model: 'claude-3-5-sonnet-latest', provider: 'tetrate' }, // Higher quality for content improvement\n        { model: 'gemini-1.5-flash-8b', provider: 'google' } // Fallback\n      ],\n      generate: [\n        { model: 'claude-3-5-sonnet-latest', provider: 'tetrate' }, // Higher quality for content generation\n        { model: 'gemini-1.5-flash-8b', provider: 'google' } // Fallback\n      ]\n    };\n\n    return defaults[workflowType];\n  }\n}\n\n/**\n * Factory function for creating Shakespeare instances\n */\nexport function createShakespeare(rootDir?: string, dbPath?: string, options?: ShakespeareOptions): Shakespeare {\n  return new Shakespeare(rootDir, dbPath, options);\n}\n\n/**\n * Auto-detect project type based on file structure\n */\nasync function detectProjectType(rootDir: string): Promise<keyof typeof CONTENT_COLLECTIONS | 'custom'> {\n  try {\n    const { existsSync } = await import('fs');\n    const { join } = await import('path');\n    \n    // Check for Astro\n    if (existsSync(join(rootDir, 'astro.config.mjs')) || \n        existsSync(join(rootDir, 'astro.config.js')) ||\n        existsSync(join(rootDir, 'src/content'))) {\n      return 'astro';\n    }\n    \n    // Check for Next.js\n    if (existsSync(join(rootDir, 'next.config.js')) || \n        existsSync(join(rootDir, 'next.config.mjs'))) {\n      return 'nextjs';\n    }\n    \n    // Check for Gatsby\n    if (existsSync(join(rootDir, 'gatsby-config.js')) || \n        existsSync(join(rootDir, 'gatsby-config.ts'))) {\n      return 'gatsby';\n    }\n    \n    return 'custom';\n  } catch {\n    return 'custom';\n  }\n}\n\n/**\n * Get model options based on optimization preference\n */\nfunction getOptimizedModelOptions(config: ShakespeareConfig): AIModelOptions | undefined {\n  if (config.modelOptions) return config.modelOptions;\n  \n  if (config.model || config.provider) {\n    return {\n      provider: config.provider,\n      model: config.model\n    };\n  }\n  \n  if (config.costOptimized) {\n    return {\n      provider: 'google',\n      model: 'gemini-1.5-flash'\n    };\n  }\n  \n  if (config.qualityFirst) {\n    return {\n      provider: 'anthropic', \n      model: 'claude-3-5-sonnet'\n    };\n  }\n  \n  return undefined;\n}\n\n/**\n * Legacy factory functions (maintained for backward compatibility)\n */\nexport const ShakespeareFactory = {\n  /** Create Shakespeare for Astro projects with content collections */\n  forAstro: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) => \n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'astro' }),\n  \n  /** Create Shakespeare for Next.js projects */\n  forNextJS: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'nextjs' }),\n  \n  /** Create Shakespeare for Gatsby projects */\n  forGatsby: (rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: 'gatsby' }),\n  \n  /** Create Shakespeare with custom content collection configuration */\n  forCustom: (contentConfig: ContentCollectionConfig, rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, contentCollection: contentConfig }),\n\n  /** Create cost-optimized Shakespeare with specific model configuration */\n  withCostOptimization: (modelOptions: AIModelOptions, rootDir?: string, dbPath?: string, options: ShakespeareOptions = {}) =>\n    new Shakespeare(rootDir, dbPath, { ...options, defaultModelOptions: modelOptions })\n};\n", "#!/usr/bin/env node\n\nimport { Shakespeare } from '..';\nimport path from 'path';\n\nasync function main() {\n  const contentDir = process.env.CONTENT_DIR || path.join(process.cwd(), 'content');\n  const dbPath = process.env.DB_PATH || path.join(process.cwd(), '.shakespeare', 'content-db.json');\n\n  const shakespeare = new Shakespeare(contentDir, dbPath);\n  await shakespeare.initialize();\n\n  const worstContentPath = shakespeare.getWorstScoringContent();\n  if (!worstContentPath) {\n    console.log('No content needs improvement');\n    return;\n  }\n\n  console.log(`Improving content: ${worstContentPath}`);\n  await shakespeare.improveContent(worstContentPath);\n  console.log('Content improvement completed');\n}\n\nmain().catch(console.error);\n"],
  "mappings": "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",
  "names": ["fs", "path", "fs", "path", "path", "fs", "entry", "scores", "join", "existsSync", "existsSync", "join", "path"]
}
